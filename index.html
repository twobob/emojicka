<!DOCTYPE html>
<html><head><base href="https://ÏˆÏ€.com/dev/world/"><title>Emojicka World - Wildlife and Gold Rush</title>
<style>
body, html { margin: 0; padding: 0; height: 100%; overflow: hidden; font-family: Arial, sans-serif; font-size: 1.5em; }
#gameCanvas { background: #8FBC8F; }
#ui { position: fixed; top: 10px; left: 10px; background: rgba(255,255,255,0.7); padding: 10px; border-radius: 5px; z-index: 10; }
#posi {font-size: .5em;}
#wealthUI { position: fixed; top: 10px; right: 10px; background: rgba(255,255,255,0.7); padding: 10px; border-radius: 5px; z-index: 10; }
#pathfindingDialog { display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%,-50%); background: white; padding: 20px; border-radius: 5px; box-shadow: 0 0 10px rgba(0,0,0,0.3); z-index: 20; }
#loadingIndicator { display: none; position: fixed; bottom: 10px; right: 10px; background: rgba(0,0,0,0.7); color: white; padding: 10px; border-radius: 5px; z-index: 30; }
#minimap { position: fixed; bottom: 10px; right: 10px; width: 350px; height: 350px; background: rgba(0,0,0,0.5); border: 2px solid white; z-index: 40; }
#worldMap { display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.9); border: 4px solid white; z-index: 100; }
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<div id="ui">
    <div id="posi">Position: X: <span id="xPos"></span>, Y: <span id="yPos"></span></div>
    <div>Biome: <span id="biome"></span></div>
    <div>Status: <span id="status"></span></div>
    <div>Idea: <span id="plan"></span></div>
</div>
<div id="wealthUI">
    <div>Gold: <span id="goldCount">0</span></div>
</div>
<div id="pathfindingDialog">
    <h3>Enter Target Position</h3>
    <form id="pathfindingForm">
        <label for="targetX">X:</label>
        <input type="number" id="targetX" required><br><br>
        <label for="targetY">Y:</label>
        <input type="number" id="targetY" required><br><br>
        <button type="submit">Find Path</button>
    </form>
</div>
<div id="loadingIndicator">Loading...</div>
<canvas id="minimap"></canvas>
<canvas id="worldMap"></canvas>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const minimapCanvas = document.getElementById('minimap');
const minimapCtx = minimapCanvas.getContext('2d');
const worldMapCanvas = document.getElementById('worldMap');
const worldMapCtx = worldMapCanvas.getContext('2d');

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;
minimapCanvas.width = 200;
minimapCanvas.height = 200;

// World map setup - 89% of screen width/height
worldMapCanvas.width = Math.floor(window.innerWidth * 0.89);
worldMapCanvas.height = Math.floor(window.innerHeight * 0.89);

let worldMapVisible = false;
let gamePaused = false;

const xPosElement = document.getElementById('xPos');
const yPosElement = document.getElementById('yPos');
const biomeElement = document.getElementById('biome');
const statusElement = document.getElementById('status');
const planElement = document.getElementById('plan');
const goldCountElement = document.getElementById('goldCount');
const pathfindingDialog = document.getElementById('pathfindingDialog');
const pathfindingForm = document.getElementById('pathfindingForm');
const targetXInput = document.getElementById('targetX');
const targetYInput = document.getElementById('targetY');
const loadingIndicator = document.getElementById('loadingIndicator');

const MAX_SEARCH_DISTANCE = 4096; // 204.8 tiles at 20 pixels per tile
const MAX_ANIMAL_SEARCH_DISTANCE = 400; // Max search distance for animal random path

// Terrain height thresholds
    const HEIGHT_SNOW_THRESHOLD = 0.75; // Snow appears above this height
const HEIGHT_MOUNTAIN_THRESHOLD = 0.65; // Mountain rocks appear above this height

// Player settings
const PLAYER_SPEED = 300; // pixels per second (lower = slower, higher = faster)
const PLAYER_SIZE = 20; // size of player emoji in pixels
const SWIMMING_SPEED_MULTIPLIER = 0.2; // Swimming is 5x slower (0.2 = 1/5 speed)
const SWIMMING_PATHFINDING_COST = 1.0 / SWIMMING_SPEED_MULTIPLIER; // Pathfinding cost matches speed penalty

const TILE_TYPES = {
    DEEP_WATER: 0, SHALLOW_WATER: 1, BEACH: 2, GRASS: 3, FOREST: 4, DESERT: 5, ROCK: 6, 
    CITY_PAVED: 7, TOWN_ROAD: 8, VILLAGE_MUD: 9, SNOW: 10, MOUNTAIN_ROCK: 11
};

let lastPathCompletionTime = 0;
const AUTO_PATH_DELAY = 3000; // 3 seconds in milliseconds

const TILE_SIZE = 20;
const CHUNK_SIZE = 40;
const WORLD_WIDTH = 200;
const WORLD_HEIGHT = 200;
const MINIMAP_SCALE = 0.08;
const BOAT_SPAWN_CHANCE = 0.05;
const GOLD_SPAWN_CHANCE = 0.002;
const ANIMAL_SPAWN_CHANCE = 0.005;

const ANIMAL_DEATH_CHANCE = 0.0001;

const FISH_SPAWN_CHANCE = 0.001;
const ANIMAL_SPAWN_MAX = 200;
const LAND_ANIMAL_SPAWN_MAX = ANIMAL_SPAWN_MAX / 2;
const FISH_SPAWN_MAX = ANIMAL_SPAWN_MAX / 2;


const GOLD_PICKUP_RADIUS = 2 * TILE_SIZE; // More forgiving pickup radius

const ANIMAL_TYPES = [
  '\u{1F98C}', // Deer
  '\u{1F43B}', // Bear
  '\u{1F43A}', // Wolf
  '\u{1F98A}', // Fox
  '\u{1F430}', // Rabbit
  '\u{1F434}', // Horse
  '\u{1F437}', // Pig
  '\u{1F42E}', // Cow
  '\u{1F411}', // Sheep
  '\u{1F418}', // Elephant
  '\u{1F42D}', // Mouse
  '\u{1F42F}', // Tiger
  '\u{1F41F}'  // Fish
];


const PLAYER_EMOJIS = {
    STANDING: '\u{1F9CD}', // Person standing
    WALKING: '\u{1F6B6}',  // Person walking
    RUNNING: '\u{1F3C3}',  // Person running
    ROWING: '\u{1F6A3}',   // Person rowing
    SWIMMING: '\u{1F3CA}', // Person swimming
    SKIING: '\u{26F7}',    // Skier (descending snow)
    SNOWBOARDING: '\u{1F3C2}', // Snowboarder (climbing snow)
    CLIMBING: '\u{1F9D7}\u200D\u2642\uFE0F' // Man climbing (mountain rocks)
};

// NPC types with emoji, speech, and categories
const NPC_TYPES = {
    royal: [
        { emoji: '\u{1F451}', name: 'King', speech: 'The crown is heavy, but just.', unique: true },
        { emoji: '\u{1F478}', name: 'Queen', speech: 'Our kingdom prospers.', unique: true },
        { emoji: '\u{1F934}', name: 'Prince', speech: 'Adventure awaits!' },
        { emoji: '\u{1F478}', name: 'Princess', speech: 'Have you seen my kingdom?' }
    ],
    common: [
        { emoji: '\u{1F9D9}', name: 'Mage', speech: 'Seeking arcane knowledge?' },
        { emoji: '\u{1F9D9}\u200D\u2642\uFE0F', name: 'Wizard', speech: 'The stars align tonight...' },
        { emoji: '\u{1F9DD}', name: 'Elf', speech: 'The forest calls to me.' },
        { emoji: '\u{1F9DE}', name: 'Genie', speech: 'Three wishes? Not today.' },
        { emoji: '\u{1F9D1}\u200D\u{1F373}', name: 'Cook', speech: 'Fancy a hot meal?' },
        { emoji: '\u{1F9D1}\u200D\u{1F33E}', name: 'Farmer', speech: 'Good harvest this year.' },
        { emoji: '\u{1F46E}', name: 'Guard', speech: 'Stay out of trouble.' },
        { emoji: '\u{1F9B8}', name: 'Hero', speech: 'Evil shall not prevail!' },
        { emoji: '\u{1F9D1}\u200D\u2696\uFE0F', name: 'Judge', speech: 'Justice will be served.' },
        { emoji: '\u{1F473}', name: 'Merchant', speech: 'Finest wares in the land!' },
        { emoji: '\u{1F9D9}\u200D\u2640\uFE0F', name: 'Witch', speech: 'Need a potion?' },
        { emoji: '\u{1F935}', name: 'Sage', speech: 'Wisdom comes with time.' },
        { emoji: '\u{1F9D1}\u200D\u{1F52C}', name: 'Scientist', speech: 'Fascinating discovery!' },
        { emoji: '\u{1F9D1}\u200D\u{1F3A8}', name: 'Artist', speech: 'Beauty is everywhere.' }
    ],
    undead: [
        { emoji: '\u{1F9DF}', name: 'Zombie', speech: 'Braaaains... or gold?' },
        { emoji: '\u{1F9DB}', name: 'Vampire', speech: 'The night is young...' }
    ]
};

// BOID parameters
const SEPARATION_DISTANCE = 50;
const ALIGNMENT_DISTANCE = 100;
const COHESION_DISTANCE = 150;
const MAX_SPEED = 50;
const MAX_FORCE = 0.02;

// animation parameters
const ANIMATION_INTERVAL = 50; // milliseconds between frames

let playerAnimationFrame = 0;
let lastAnimationTime = 0;

let animatedEmojis = [];

let frameTimeSum = 0;
// ============================================================================
// GAME LOOP TIMING CONFIGURATION
// ============================================================================
// Centralised frame scheduler with delta-time integration for smooth,
// frame-rate independent movement and physics.
//
// Benefits:
// - Consistent movement speed across different frame rates
// - Prevents stuttering and uneven physics
// - Protects against "spiral of death" from lag spikes
// - Clear separation between update (game state) and render (display)
// ============================================================================

const TARGET_FPS = 60;
const TARGET_FRAME_TIME = 1000 / TARGET_FPS; // ~16.67ms per frame
const MAX_DELTA_TIME = 0.1; // Cap delta at 100ms to prevent huge jumps from lag

let lastFrameTime = performance.now();
let animalPathTimeSum = 0;
let frameCount = 0;

// ============================================================================
// BINARY HEAP - Efficient priority queue for pathfinding
// ============================================================================
// Binary Heap implementation for more efficient open set management
class BinaryHeap {
    constructor(scoreFunction) {
        this.content = [];
        this.scoreFunction = scoreFunction;
        this.nodeMap = new Map(); // For O(1) lookup instead of O(n)
    }
    
    _getKey(node) {
        return `${node.x},${node.y},${node.inBoat},${node.isSwimming},${node.isClimbing},${node.isSkiing},${node.isSnowboarding}`;
    }

    push(element) {
        this.content.push(element);
        this.nodeMap.set(this._getKey(element), element);
        this.bubbleUp(this.content.length - 1);
    }

    pop() {
        const result = this.content[0];
        const end = this.content.pop();
        if (result) this.nodeMap.delete(this._getKey(result));
        if (this.content.length > 0) {
            this.content[0] = end;
            this.sinkDown(0);
        }
        return result;
    }

    remove(node) {
        const key = this._getKey(node);
        const i = this.content.findIndex(el => this._getKey(el) === key);
        if (i === -1) return;
        
        const end = this.content.pop();
        this.nodeMap.delete(key);
        
        if (i !== this.content.length) {
            this.content[i] = end;
            if (end) {
                this.nodeMap.set(this._getKey(end), end);
                if (this.scoreFunction(end) < this.scoreFunction(node)) {
                    this.bubbleUp(i);
                } else {
                    this.sinkDown(i);
                }
            }
        }
    }

    size() {
        return this.content.length;
    }

    clear() {
        this.content.length = 0;
        this.nodeMap.clear();
    }

    contains(node) {
        return this.nodeMap.has(this._getKey(node));
    }

    getNode(node) {
        return this.nodeMap.get(this._getKey(node));
    }

    updateNode(existing, newValues) {
        // Find index of existing node
        const idx = this.content.indexOf(existing);
        if (idx === -1) return;
        
        // Update values
        existing.g = newValues.g;
        existing.f = newValues.f;
        existing.parent = newValues.parent;
        existing.inBoat = newValues.inBoat;
        existing.isSwimming = newValues.isSwimming;
        existing.isClimbing = newValues.isClimbing;
        existing.isSkiing = newValues.isSkiing;
        existing.isSnowboarding = newValues.isSnowboarding;
        
        // Re-heapify from this position (bubble up since f decreased)
        this.bubbleUp(idx);
    }

    bubbleUp(n) {
        const element = this.content[n];
        while (n > 0) {
            const parentN = ((n + 1) >> 1) - 1;
            const parent = this.content[parentN];
            if (this.scoreFunction(element) >= this.scoreFunction(parent)) break;
            this.content[parentN] = element;
            this.content[n] = parent;
            n = parentN;
        }
    }

    sinkDown(n) {
        const length = this.content.length;
        const element = this.content[n];
        const elemScore = this.scoreFunction(element);

        while (true) {
            const child2N = (n + 1) << 1;
            const child1N = child2N - 1;
            let swap = null;
            let child1Score;
            if (child1N < length) {
                const child1 = this.content[child1N];
                child1Score = this.scoreFunction(child1);
                if (child1Score < elemScore) swap = child1N;
            }
            if (child2N < length) {
                const child2 = this.content[child2N];
                const child2Score = this.scoreFunction(child2);
                if (child2Score < (swap === null ? elemScore : child1Score)) swap = child2N;
            }
            if (swap === null) break;
            this.content[n] = this.content[swap];
            this.content[swap] = element;
            n = swap;
        }
    }
}

// ============================================================================
// OBJECT POOLS - Eliminate GC churn from per-frame allocations
// ============================================================================
// Reuse arrays, maps, and objects instead of creating new ones every frame.
// This eliminates garbage collection spikes and improves performance.
// ============================================================================

// Reusable arrays for moveFish (avoid creating new arrays every frame)
const activeFishPool = [];
const neighborsPool = [];

// Reusable spatial grid for fish (avoid new Map() every frame)
const fishSpatialGrid = new Map();

// Reusable set for expired fish tracking
const expiredFishSet = new Set();

// Reusable arrays for moveAnimals
const nearAnimalsPool = [];
const farAnimalsPool = [];

// Reusable pathfinding structures (avoid new BinaryHeap/Set every call)
const pathfindingHeap = new BinaryHeap(node => node.f);
const pathfindingClosedSet = new Set();
const pathfindingHeightCache = new Map();

let chunks = {};
let boats = [];
let goldNuggets = [];
let landAnimals = [];
let fishFlock = [];
let totalFrameTime = 0;
let npcs = [];

// Settlements: placed after world gen
let settlements = { city: null, towns: [], villages: [] };

methodTimes = {};

// Debug mode
let debugMode = false;

// Limit animal pathfinding per frame to avoid long tasks
let animalPathfindBudgetPerFrame = 2;
let animalPathfindSlots = 0;

let camera = {x: 0, y: 0};
let path = [];
let target = null;

player = {
    x: 0, y: 0, size: PLAYER_SIZE, inBoat: false, isSwimming: false, isClimbing: false, isSkiing: false, isSnowboarding: false, gold: 0,
    isMoving: false,
    currentEmoji: PLAYER_EMOJIS.STANDING,
    direction: 'left', // 'left' or 'right'
    lastMoveTime: 0,
    distanceTravelled: 0,
    targetX: 0, // lerp target position
    targetY: 0,
    currentPathStep: null
};

class Fish {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        // Velocity in px/sec; start with a random heading
        const angle = Math.random() * Math.PI * 2;
        this.vx = Math.cos(angle);
        this.vy = Math.sin(angle);

        // Steering and timing controls (all per-fish to stagger work)
        const now = Date.now();
        this.nextSteerTime = now + 100 + Math.random() * 500; // 100-600ms
        this.nextWaypointTime = now + 3000 + Math.random() * 5000; // 3-8s
        this.nextSpeedTime = now + 2000 + Math.random() * 4000; // 2-6s
        this.lastMoveTime = now; // for dt integration

        // Waypoint the fish tends to head towards (in world px)
        this.waypoint = null;

        // Smooth speed variation (px/sec)
        this.speed = 25 + Math.random() * 25; // 25-50
        this.targetSpeed = this.speed;
        this.maxSpeed = 60; // hard cap px/sec
        this.minSpeed = 10;

        // Cached steering force to reuse between steer ticks
        this.ax = 0;
        this.ay = 0;

        this.lifespan = Math.random() * 345000 + 15000; // Random lifespan between 15 and 360 seconds
        this.birthTime = Date.now(); // Record the birth time
    }

    update(neighbors, currentTime) {
        // Expiry check
        if (currentTime - this.birthTime > this.lifespan) return true;

        // Decide new waypoint occasionally; pick mostly ahead of current heading with jitter
        if (currentTime >= this.nextWaypointTime || !this.waypoint) {
            const aheadDist = 150 + Math.random() * 250; // 150-400 px
            const jitter = (Math.random() - 0.5) * Math.PI * 0.5; // +/- 90deg jitter
            const heading = Math.atan2(this.vy, this.vx) + jitter;
            let wx = this.x + Math.cos(heading) * aheadDist;
            let wy = this.y + Math.sin(heading) * aheadDist;
            // Keep inside deep water if possible
            const deep = findNearestDeepWater(wx, wy);
            if (deep) { wx = deep.x; wy = deep.y; }
            this.waypoint = { x: wx, y: wy };
            this.nextWaypointTime = currentTime + 3000 + Math.random() * 5000; // 3-8s
        }

        // Smoothly vary target speed sometimes
        if (currentTime >= this.nextSpeedTime) {
            this.targetSpeed = this.minSpeed + Math.random() * (this.maxSpeed - this.minSpeed);
            this.nextSpeedTime = currentTime + 2000 + Math.random() * 4000; // 2-6s
        }

        // Occasionally recompute steering forces; otherwise reuse cached ax/ay to be cheap
        if (currentTime >= this.nextSteerTime) {
            const separation = this.separate(neighbors);
            const alignment = this.align(neighbors);
            const cohesion = this.cohesion(neighbors);
            const stayInWater = this.stayInDeepWater();
            const toWaypoint = this.seekWaypoint();
            const wander = this.wander();

            // Blend forces with conservative weights for smoothness
            const wSep = 1.4, wAli = 0.6, wCoh = 0.35, wWater = 2.5, wWp = 0.7, wWan = 0.25;
            this.ax = separation.x * wSep + alignment.x * wAli + cohesion.x * wCoh + stayInWater.x * wWater + toWaypoint.x * wWp + wander.x * wWan;
            this.ay = separation.y * wSep + alignment.y * wAli + cohesion.y * wCoh + stayInWater.y * wWater + toWaypoint.y * wWp + wander.y * wWan;

            // Stagger next steer so not all fish think on same tick
            this.nextSteerTime = currentTime + 120 + Math.random() * 380; // 120-500ms
        }

        // Integrate motion with dt for smooth movement
        const dt = Math.max(0, (currentTime - this.lastMoveTime) / 1000);
        this.lastMoveTime = currentTime;

        // Accelerate by cached steering, with gentle damping to avoid runaway
        const damping = 0.98;
        this.vx = (this.vx + this.ax) * damping;
        this.vy = (this.vy + this.ay) * damping;

        // Adjust speed smoothly toward targetSpeed
        let speed = Math.hypot(this.vx, this.vy);
        const desired = this.targetSpeed;
        if (speed > 1e-3) {
            const scaled = easeScalar(speed, desired, dt, 0.75);
            const s = scaled / speed;
            this.vx *= s; this.vy *= s;
            speed = scaled;
        } else {
            // If nearly stopped, nudge forward along last acceleration or a random heading
            const ang = Math.atan2(this.ay, this.ax) || Math.random() * Math.PI * 2;
            this.vx = Math.cos(ang) * desired;
            this.vy = Math.sin(ang) * desired;
        }

        // Hard clamp to absolute cap just in case
        if (speed > this.maxSpeed) {
            this.vx = (this.vx / speed) * this.maxSpeed;
            this.vy = (this.vy / speed) * this.maxSpeed;
            speed = this.maxSpeed;
        }

        // Move by velocity scaled by dt, but enforce deep-water constraint hard
        let nx = this.x + this.vx * dt;
        let ny = this.y + this.vy * dt;
        const nTileX = Math.floor(nx / TILE_SIZE);
        const nTileY = Math.floor(ny / TILE_SIZE);
        if (getTileType(nTileX, nTileY) === TILE_TYPES.DEEP_WATER) {
            this.x = nx;
            this.y = ny;
        } else {
            // Snap back into nearest deep water and steer inward
            const deep = findNearestDeepWater(nx, ny) || findNearestDeepWater(this.x, this.y);
            if (deep) {
                this.x = deep.x;
                this.y = deep.y;
                const dir = direction(this.x, this.y, deep.x, deep.y);
                const speedAfter = Math.max(this.minSpeed, Math.min(this.targetSpeed, this.maxSpeed)) * 0.6;
                if (dir.d > 0) {
                    this.vx = dir.x * speedAfter;
                    this.vy = dir.y * speedAfter;
                }
                // Bias future steering toward centre of deep area
                this.waypoint = deep;
            } else {
                // As a safeguard, reflect and dampen velocity
                this.vx *= -0.5;
                this.vy *= -0.5;
            }
        }

        return false;
    }

    separate(neighbors) {
        let steerX = 0, steerY = 0, count = 0;
    let processed = 0, limit = 16; // cap neighbour samples for perf
        for (const other of neighbors) {
            const dx = this.x - other.x;
            const dy = this.y - other.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            if (distance > 0 && distance < SEPARATION_DISTANCE) {
                steerX += dx / distance;
                steerY += dy / distance;
                count++;
            }
            processed++;
            if (processed >= limit) break;
        }
        if (count > 0) {
            steerX /= count;
            steerY /= count;
            const steerMag = Math.sqrt(steerX * steerX + steerY * steerY);
            if (steerMag > 0) {
                steerX = (steerX / steerMag) * MAX_FORCE;
                steerY = (steerY / steerMag) * MAX_FORCE;
            }
        }
        return { x: steerX, y: steerY };
    }

    align(neighbors) {
        let avgVX = 0, avgVY = 0, count = 0;
    let processed = 0, limit = 16; // cap neighbour samples for perf
        for (const other of neighbors) {
            const dx = this.x - other.x;
            const dy = this.y - other.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            if (distance > 0 && distance < ALIGNMENT_DISTANCE) {
                avgVX += other.vx;
                avgVY += other.vy;
                count++;
            }
            processed++;
            if (processed >= limit) break;
        }
        if (count > 0) {
            avgVX /= count;
            avgVY /= count;
            const mag = Math.sqrt(avgVX * avgVX + avgVY * avgVY);
            if (mag > 0) {
                avgVX = (avgVX / mag) * MAX_FORCE;
                avgVY = (avgVY / mag) * MAX_FORCE;
            }
        }
        return { x: avgVX, y: avgVY };
    }

    cohesion(neighbors) {
        let centerX = 0, centerY = 0, count = 0;
    let processed = 0, limit = 16; // cap neighbour samples for perf
        for (const other of neighbors) {
            const dx = this.x - other.x;
            const dy = this.y - other.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            if (distance > 0 && distance < COHESION_DISTANCE) {
                centerX += other.x;
                centerY += other.y;
                count++;
            }
            processed++;
            if (processed >= limit) break;
        }
        if (count > 0) {
            centerX /= count;
            centerY /= count;
            const dx = centerX - this.x;
            const dy = centerY - this.y;
            const mag = Math.sqrt(dx * dx + dy * dy);
            if (mag > 0) {
                return {
                    x: (dx / mag) * MAX_FORCE,
                    y: (dy / mag) * MAX_FORCE
                };
            }
        }
        return { x: 0, y: 0 };
    }

    stayInDeepWater() {
        const tileX = Math.floor(this.x / TILE_SIZE);
        const tileY = Math.floor(this.y / TILE_SIZE);
        if (getTileType(tileX, tileY) !== TILE_TYPES.DEEP_WATER) {
            // Find nearest deep water tile
            const nearestDeepWater = findNearestDeepWater(this.x, this.y);
            if (nearestDeepWater) {
                const dx = nearestDeepWater.x - this.x;
                const dy = nearestDeepWater.y - this.y;
                const mag = Math.sqrt(dx * dx + dy * dy);
                if (mag > 0) {
                    return {
                        x: (dx / mag) * MAX_FORCE * 5, // Much stronger force to stay in deep water
                        y: (dy / mag) * MAX_FORCE * 5
                    };
                }
            }
        }
        return { x: 0, y: 0 };
    }

    seekWaypoint() {
        if (!this.waypoint) return { x: 0, y: 0 };
        const dx = this.waypoint.x - this.x;
        const dy = this.waypoint.y - this.y;
        const dist = Math.hypot(dx, dy);
        if (dist < 20) return { x: 0, y: 0 }; // close enough; don't oversteer
        const nx = dx / dist, ny = dy / dist;
        return { x: nx * MAX_FORCE, y: ny * MAX_FORCE };
    }

    wander() {
        // Small random turning to avoid perfect alignment
        const angleJitter = (Math.random() - 0.5) * 0.3; // +/-0.15 rad
        const h = Math.atan2(this.vy, this.vx) + angleJitter;
        return { x: Math.cos(h) * MAX_FORCE * 0.5, y: Math.sin(h) * MAX_FORCE * 0.5 };
    }
}


// Land animal with centralized update: variable speed, cheap wandering, occasional pathing
class LandAnimal {
    constructor(x, y, type) {
        this.x = x;
        this.y = y;
        this.type = type;
        this.isFish = false;

        // Movement and timing
        const now = Date.now();
        this.vx = 0; this.vy = 0;
        this.speed = 30 + Math.random() * 20; // 30-50 px/sec
        this.targetSpeed = this.speed;
        this.minSpeed = 10; this.maxSpeed = 70;
        this.nextSpeedTime = now + 2000 + Math.random() * 4000; // 2-6s
        this.lastMoveTime = now;

    // Behaviour control: 'wander' or 'path'
        this.behavior = 'wander';
        this.nextBehaviorTime = now + 3000 + Math.random() * 6000; // 3-9s

        // Wandering
        this.waypoint = null;
        this.nextWanderPick = now + 800 + Math.random() * 1500; // 0.8-2.3s

        // Pathing
        this.path = [];
        this.nextPathfindingTime = now + 1500 + Math.random() * 2500; // 1.5-4s
    }

    update(currentTime) {
        // Decide on behaviour periodically
        if (currentTime >= this.nextBehaviorTime) {
            // 45% wander, 55% path for a bit of intent
            this.behavior = Math.random() < 0.45 ? 'wander' : 'path';
            this.nextBehaviorTime = currentTime + 3000 + Math.random() * 7000; // 3-10s
            // Clear or plan accordingly
            if (this.behavior === 'wander') {
                this.path = [];
                this.waypoint = null; // will pick soon
            } else {
                // force a plan soon
                this.nextPathfindingTime = Math.min(this.nextPathfindingTime, currentTime + 200);
            }
        }

        // Smooth speed changes
        if (currentTime >= this.nextSpeedTime) {
            this.targetSpeed = this.minSpeed + Math.random() * (this.maxSpeed - this.minSpeed);
            this.nextSpeedTime = currentTime + 2000 + Math.random() * 4000;
        }

        const dt = Math.max(0, (currentTime - this.lastMoveTime) / 1000);
        this.lastMoveTime = currentTime;

        // Ease current speed
        const velMag = Math.hypot(this.vx, this.vy);
        const desired = this.targetSpeed;
        if (velMag > 1e-3) {
            const scaled = easeScalar(velMag, desired, dt, 0.9);
            const s = scaled / velMag;
            this.vx *= s; this.vy *= s;
        }

        if (this.behavior === 'wander') {
            this.updateWander(currentTime, dt);
        } else {
            this.updatePathing(currentTime, dt);
        }
    }

    updateWander(currentTime, dt) {
        // Occasionally pick a small local waypoint and walk toward it
        if (currentTime >= this.nextWanderPick || !this.waypoint) {
            const rangeTiles = 4 + Math.floor(Math.random() * 4); // 4-7 tiles
            this.waypoint = pickLocalWaypoint(this.x, this.y, rangeTiles, isWalkableLand);
            this.nextWanderPick = currentTime + 1000 + Math.random() * 2000; // 1-3s
        }

        if (this.waypoint) {
            const dx = this.waypoint.x - this.x;
            const dy = this.waypoint.y - this.y;
            const dist = Math.hypot(dx, dy);
            if (dist < 2) {
                this.waypoint = null; // reached; will pick a new one later
            } else {
                const step = this.targetSpeed * dt;
                const nx = dx / dist, ny = dy / dist;
                const nxPos = this.x + nx * step;
                const nyPos = this.y + ny * step;
                if (isWalkable(nxPos, nyPos, false, false)) {
                    this.x = nxPos; this.y = nyPos;
                    this.vx = nx * this.targetSpeed; this.vy = ny * this.targetSpeed;
                } else {
                    // blocked, force new pick next tick
                    this.waypoint = null;
                }
            }
        }
    }

    updatePathing(currentTime, dt) {
        // Occasionally (re)plan a random short path
        if ((!this.path || this.path.length === 0) && currentTime >= this.nextPathfindingTime) {
            if (animalPathfindSlots > 0) {
                this.planRandomPath();
                animalPathfindSlots--;
                this.nextPathfindingTime = currentTime + 2000 + Math.random() * 4000; // 2-6s
            } else {
                // No budget this frame, try again soon to stagger work
                this.nextPathfindingTime = currentTime + 200 + Math.random() * 300;
            }
        }

        if (this.path && this.path.length > 0) {
            const nextStep = this.path[0];
            const dx = nextStep.x - this.x;
            const dy = nextStep.y - this.y;
            const dist = Math.hypot(dx, dy);
            if (dist < 2) {
                // Snap and advance
                this.x = nextStep.x; this.y = nextStep.y;
                this.path.shift();
            } else {
                const step = this.targetSpeed * dt;
                const nx = dx / dist, ny = dy / dist;
                const nxPos = this.x + nx * step;
                const nyPos = this.y + ny * step;
                if (isWalkable(nxPos, nyPos, false, false)) {
                    this.x = nxPos; this.y = nyPos;
                    this.vx = nx * this.targetSpeed; this.vy = ny * this.targetSpeed;
                } else {
                    // hit something unexpected, replan soon
                    this.path = [];
                    this.nextPathfindingTime = Math.min(this.nextPathfindingTime, currentTime + 300);
                }
            }
        }
    }

    planRandomPath() {
        let targetX, targetY;
        let attempts = 0;
        const maxAttempts = 8; // keep attempts modest to avoid heavy bursts
        while (attempts++ < maxAttempts) {
            const randomDistance = Math.random() * MAX_ANIMAL_SEARCH_DISTANCE;
            const randomAngle = Math.random() * Math.PI * 2;
            targetX = this.x + randomDistance * Math.cos(randomAngle);
            targetY = this.y + randomDistance * Math.sin(randomAngle);
            // Clamp to world
            const c = clampToWorldPos(targetX, targetY);
            targetX = c.x; targetY = c.y;
            const tType = getTileType(Math.floor(targetX / TILE_SIZE), Math.floor(targetY / TILE_SIZE));
            if (tType !== TILE_TYPES.DEEP_WATER && tType !== TILE_TYPES.SHALLOW_WATER && tType !== TILE_TYPES.ROCK) {
                const newPath = findPath(this.x, this.y, targetX, targetY, false, MAX_ANIMAL_SEARCH_DISTANCE);
                if (newPath) { this.path = newPath; return; }
            }
        }
        // fallback: switch to wander if no path found
        this.behavior = 'wander';
        this.waypoint = null;
    }

    pickLocalWaypoint(rangeTiles) {
        const range = rangeTiles * TILE_SIZE;
        for (let i = 0; i < 20; i++) {
            const a = Math.random() * Math.PI * 2;
            const d = (0.5 + Math.random()) * range; // bias away from zero
            let wx = this.x + Math.cos(a) * d;
            let wy = this.y + Math.sin(a) * d;
            wx = Math.max(0, Math.min(wx, WORLD_WIDTH * TILE_SIZE));
            wy = Math.max(0, Math.min(wy, WORLD_HEIGHT * TILE_SIZE));
            if (isWalkable(wx, wy, false, false)) return { x: wx, y: wy };
        }
        return null;
    }
}


function noise(x, y) {
    const X = Math.floor(x) & 255, Y = Math.floor(y) & 255;
    x -= Math.floor(x); y -= Math.floor(y);
    const u = fade(x), v = fade(y);
    const A = p[X]+Y, B = p[X+1]+Y;
    return lerp(v, lerp(u, grad(p[A], x, y), grad(p[B], x-1, y)),
                  lerp(u, grad(p[A+1], x, y-1), grad(p[B+1], x-1, y-1)));
}

function fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }
function lerp(t, a, b) { return a + t * (b - a); }
function grad(hash, x, y) {
    const h = hash & 15;
    const u = h < 8 ? x : y;
    const v = h < 4 ? y : (h === 12 || h === 14 ? x : 0);
    return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
}

const p = new Array(512);
for (let i = 0; i < 256; i++) p[i] = p[i + 256] = Math.floor(Math.random() * 256);

// Height map noise (low frequency for elevation)
function heightNoise(x, y) {
    // Use lower frequency for broader features, but not TOO low or we get no peaks
    const h1 = noise(x / 80, y / 80); // Broad features (base terrain)
    const h2 = noise(x / 40 + 5000, y / 40 + 5000); // Medium features (hills)
    const h3 = noise(x / 20 + 10000, y / 20 + 10000); // Fine detail (variation)
    // Combine octaves for natural-looking terrain
    const combined = h1 * 0.6 + h2 * 0.3 + h3 * 0.1;
    
    // Perlin noise returns roughly [-1, 1], so combined is also roughly [-1, 1]
    // Map to [0, 1] properly
    return (combined + 1.0) / 2.0;
}

function getBiome(x, y) {
    // Perlin noise returns roughly [-1, 1], normalise to [0, 1]
    const e = (noise(x / 50, y / 50) + 1.0) / 2.0; // Elevation/moisture
    const m = (noise(x / 30 + 1000, y / 30 + 1000) + 1.0) / 2.0; // Moisture/temperature
    const h = heightNoise(x, y); // Height/elevation (mountains) - returns [0,1]
    
    // High mountains override everything - they rise above water
    if (h > HEIGHT_SNOW_THRESHOLD) return TILE_TYPES.SNOW;
    if (h > HEIGHT_MOUNTAIN_THRESHOLD) return TILE_TYPES.MOUNTAIN_ROCK;
    
    // Water levels (only below mountain height)
    if (e < 0.3) return TILE_TYPES.DEEP_WATER;
    if (e < 0.4) return TILE_TYPES.SHALLOW_WATER;
    if (e < 0.45) return TILE_TYPES.BEACH;
    
    // Normal biomes (low elevation)
    if (e > 0.8) return m < 0.4 ? TILE_TYPES.DESERT : TILE_TYPES.GRASS;
    if (m > 0.6) return TILE_TYPES.FOREST;
    return m < 0.3 ? TILE_TYPES.DESERT : TILE_TYPES.GRASS;
}


// Add this function to find the nearest shore
function findNearestBeaches(x, y) {
    const searchRadius = 5;
    for (let r = 1; r <= searchRadius; r++) {
        for (let dx = -r; dx <= r; dx++) {
            for (let dy = -r; dy <= r; dy++) {
                const tileX = Math.floor(x / TILE_SIZE) + dx;
                const tileY = Math.floor(y / TILE_SIZE) + dy;
                const tileType = getTileType(tileX, tileY);
                if (tileType === TILE_TYPES.BEACH) {
                    return { x: tileX * TILE_SIZE, y: tileY * TILE_SIZE };
                }
            }
        }
    }
    return null;
}

// Add this function to find the nearest shore
function findNearestShore(x, y) {
    const searchRadius = 5;
    for (let r = 1; r <= searchRadius; r++) {
        for (let dx = -r; dx <= r; dx++) {
            for (let dy = -r; dy <= r; dy++) {
                const tileX = Math.floor(x / TILE_SIZE) + dx;
                const tileY = Math.floor(y / TILE_SIZE) + dy;
                const tileType = getTileType(tileX, tileY);
                if (tileType === TILE_TYPES.BEACH || tileType === TILE_TYPES.GRASS || tileType === TILE_TYPES.FOREST) {
                    return { x: tileX * TILE_SIZE, y: tileY * TILE_SIZE };
                }
            }
        }
    }
    return null;
}

function isCoast(chunk, x, y) {
    const landTypes = [TILE_TYPES.BEACH, TILE_TYPES.GRASS, TILE_TYPES.FOREST, TILE_TYPES.DESERT, TILE_TYPES.ROCK];
    const waterTypes = [TILE_TYPES.DEEP_WATER, TILE_TYPES.SHALLOW_WATER];
    const currentTile = chunk[y][x];
    if (!landTypes.includes(currentTile)) return false;
    for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
            if (dx === 0 && dy === 0) continue;
            if (waterTypes.includes(chunk[y + dy][x + dx])) return true;
        }
    }
    return false;
}

function isCoastInChunk(chunk, x, y) {
    if (x < 1 || x >= CHUNK_SIZE - 1 || y < 1 || y >= CHUNK_SIZE - 1) {
        // If we're on the edge of the chunk, we can't determine if it's a coast
        // without looking at neighboring chunks. Return false for simplicity.
        return false;
    }
    return isCoast(chunk, x, y);
}


function findNearestDeepWater(x, y) {
    const searchRadius = 4;
    let nearestDistance = Infinity;
    let nearest = null;

    for (let dy = -searchRadius; dy <= searchRadius; dy++) {
        for (let dx = -searchRadius; dx <= searchRadius; dx++) {
            const tileX = Math.floor(x / TILE_SIZE) + dx;
            const tileY = Math.floor(y / TILE_SIZE) + dy;
            if (getTileType(tileX, tileY) === TILE_TYPES.DEEP_WATER) {
                const distance = dx * dx + dy * dy;
                if (distance < nearestDistance) {
                    nearestDistance = distance;
                    nearest = { x: (tileX + 0.5) * TILE_SIZE, y: (tileY + 0.5) * TILE_SIZE };
                }
            }
        }
    }

    return nearest;
}

function generateChunk(chunkX, chunkY) {
    const chunk = Array(CHUNK_SIZE).fill().map(() => Array(CHUNK_SIZE).fill(0));
    for (let y = 0; y < CHUNK_SIZE; y++) {
        for (let x = 0; x < CHUNK_SIZE; x++) {
            const worldX = chunkX * CHUNK_SIZE + x, worldY = chunkY * CHUNK_SIZE + y;
            const biome = getBiome(worldX, worldY);
            // Place random rocks on grass using noise
            const rockNoise = (noise(worldX * 0.5, worldY * 0.5) + 1.0) / 2.0;
            chunk[y][x] = biome === TILE_TYPES.GRASS && rockNoise > 0.9 ? TILE_TYPES.ROCK : biome;
            
            // Don't place gold on rocks or water
            const finalTile = chunk[y][x];
            if (Math.random() < GOLD_SPAWN_CHANCE && finalTile !== TILE_TYPES.DEEP_WATER && finalTile !== TILE_TYPES.SHALLOW_WATER && finalTile !== TILE_TYPES.ROCK) {
                goldNuggets.push({x: worldX * TILE_SIZE, y: worldY * TILE_SIZE});
            }

            if (Math.random() < ANIMAL_DEATH_CHANCE && landAnimals.length > 1 )
            {
                //console.log("Animal died:" + animals[animals.length-1].type);
                landAnimals.pop() // Still not great logic, but preserves original intent on land animals
            }

            if (Math.random() < ANIMAL_SPAWN_CHANCE && landAnimals.length < LAND_ANIMAL_SPAWN_MAX) {
                if (biome === TILE_TYPES.GRASS || biome === TILE_TYPES.FOREST) {
                    const type = ANIMAL_TYPES[Math.floor(Math.random() * (ANIMAL_TYPES.length - 2))];
                    landAnimals.push(new LandAnimal(worldX * TILE_SIZE, worldY * TILE_SIZE, type));
                }
            }
            if (Math.random() < FISH_SPAWN_CHANCE && fishFlock.length < FISH_SPAWN_MAX) {
                if (biome === TILE_TYPES.DEEP_WATER) {
                    fishFlock.push(new Fish(worldX * TILE_SIZE, worldY * TILE_SIZE));
                } 
            }
        }
    }
    
    // Place boats after generating the chunk
    placeBoatsInChunk(chunkX, chunkY);
    
    // REMOVED: The animals.map() call was here, causing massive GC stalls.
    // Fish are now spawned as Fish objects directly.
        
    return chunk;
}

function moveFish() {
    return measureExecutionTime('moveFish', () => {
        const currentTime = Date.now();
        const pad = 200; // expand view region to pre-update
        const viewLeft = camera.x - pad, viewTop = camera.y - pad;
        const viewRight = camera.x + canvas.width + pad;
        const viewBottom = camera.y + canvas.height + pad;
        const nearRadius = 600; // also keep fish near the player active

        // Reuse pooled array for active fish (clear instead of creating new)
        activeFishPool.length = 0;
        for (const f of fishFlock) {
            if ((f.x >= viewLeft && f.x <= viewRight && f.y >= viewTop && f.y <= viewBottom) ||
                distance(player.x, player.y, f.x, f.y) <= nearRadius) {
                activeFishPool.push(f);
            }
        }

        // Build spatial hash using reusable grid (clear instead of new Map())
        const cellSize = ALIGNMENT_DISTANCE; // ~100px cells
        fishSpatialGrid.clear();
        function cellKey(cx, cy) { return cx + ',' + cy; }
        function toCell(x, y) { return { cx: Math.floor(x / cellSize), cy: Math.floor(y / cellSize) }; }

        for (const f of activeFishPool) {
            const c = toCell(f.x, f.y);
            const key = cellKey(c.cx, c.cy);
            if (!fishSpatialGrid.has(key)) fishSpatialGrid.set(key, []);
            fishSpatialGrid.get(key).push(f);
        }

        // Update active fish using local neighborhood
        expiredFishSet.clear();
        for (const f of activeFishPool) {
            const c = toCell(f.x, f.y);
            // Reuse pooled neighbors array
            neighborsPool.length = 0;
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    const key = cellKey(c.cx + dx, c.cy + dy);
                    const bucket = fishSpatialGrid.get(key);
                    if (bucket) {
                        for (const neighbor of bucket) {
                            neighborsPool.push(neighbor);
                        }
                    }
                }
            }
            const hasExpired = f.update(neighborsPool, currentTime);
            if (hasExpired) expiredFishSet.add(f);
        }

        // Clear grid cell arrays for next frame (reuse arrays)
        for (const cellArray of fishSpatialGrid.values()) {
            cellArray.length = 0;
        }

        // Also expire old fish even if inactive, cheaply
        for (const f of fishFlock) {
            if (currentTime - f.birthTime > f.lifespan) expiredFishSet.add(f);
        }

        // Remove expired fish (filter creates new array, but only occasionally)
        if (expiredFishSet.size > 0) {
            fishFlock = fishFlock.filter(f => !expiredFishSet.has(f));
        }

        // Spawn new fish to maintain population
        const desiredFishCount = FISH_SPAWN_MAX;
        const currentFishCount = fishFlock.length;
        const fishToSpawn = Math.max(0, desiredFishCount - currentFishCount);

        for (let i = 0; i < fishToSpawn; i++) {
            const newFishX = Math.random() * WORLD_WIDTH * TILE_SIZE;
            const newFishY = Math.random() * WORLD_HEIGHT * TILE_SIZE;
            if (getTileType(Math.floor(newFishX / TILE_SIZE), Math.floor(newFishY / TILE_SIZE)) === TILE_TYPES.DEEP_WATER) {
                fishFlock.push(new Fish(newFishX, newFishY));
            }
        }
    });
}







function placeBoatsInChunk(chunkX, chunkY) {
    const chunkKey = `${chunkX},${chunkY}`;
    const chunk = chunks[chunkKey];
    if (!chunk) return;

    // Check if this chunk has any coastline (land adjacent to water)
    let hasCoast = false;
    for (let y = 1; y < CHUNK_SIZE - 1 && !hasCoast; y++) {
        for (let x = 1; x < CHUNK_SIZE - 1 && !hasCoast; x++) {
            if (isCoast(chunk, x, y)) {
                hasCoast = true;
            }
        }
    }

    // Only place a boat if this chunk has a coast (part of an island)
    if (hasCoast) {
        // Place boat in shallow water or beach near land
        for (let y = 1; y < CHUNK_SIZE - 1; y++) {
            for (let x = 1; x < CHUNK_SIZE - 1; x++) {
                const tileType = chunk[y][x];
                if (tileType === TILE_TYPES.SHALLOW_WATER || tileType === TILE_TYPES.BEACH) {
                    // Check if adjacent to land
                    let hasLandNeighbor = false;
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            if (dx === 0 && dy === 0) continue;
                            const neighborType = chunk[y + dy][x + dx];
                            if (neighborType === TILE_TYPES.GRASS || neighborType === TILE_TYPES.FOREST || 
                                neighborType === TILE_TYPES.BEACH || neighborType === TILE_TYPES.DESERT) {
                                hasLandNeighbor = true;
                                break;
                            }
                        }
                        if (hasLandNeighbor) break;
                    }
                    if (hasLandNeighbor) {
                        const worldX = chunkX * CHUNK_SIZE + x;
                        const worldY = chunkY * CHUNK_SIZE + y;
                        boats.push({x: worldX * TILE_SIZE, y: worldY * TILE_SIZE});
                        return; // One boat per chunk with coast
                    }
                }
            }
        }
    }
}

function isAnimalTypeValid(animalType) {
  return ANIMAL_TYPES.includes(animalType);
}

async function loadNewArea() {
    loadingIndicator.style.display = 'block';

    const visibleChunksX = Math.ceil(canvas.width / (CHUNK_SIZE * TILE_SIZE)) + 1;
    const visibleChunksY = Math.ceil(canvas.height / (CHUNK_SIZE * TILE_SIZE)) + 1;
    const centerChunkX = Math.floor(player.x / (CHUNK_SIZE * TILE_SIZE));
    const centerChunkY = Math.floor(player.y / (CHUNK_SIZE * TILE_SIZE));

    for (let dy = -Math.floor(visibleChunksY / 2); dy <= Math.floor(visibleChunksY / 2); dy++) {
        for (let dx = -Math.floor(visibleChunksX / 2); dx <= Math.floor(visibleChunksX / 2); dx++) {
            const chunkX = centerChunkX + dx;
            const chunkY = centerChunkY + dy;
            const chunkKey = `${chunkX},${chunkY}`;
            
            if (!chunks[chunkKey]) {
                chunks[chunkKey] = generateChunk(chunkX, chunkY);
                await new Promise(resolve => setTimeout(resolve, 0));
            }
        }
    }

    loadingIndicator.style.display = 'none';
}

function drawWorld() {
    return measureExecutionTime('drawWorld', () => {
        const startX = Math.floor(camera.x / TILE_SIZE);
        const startY = Math.floor(camera.y / TILE_SIZE);
        const endX = startX + Math.ceil(canvas.width / TILE_SIZE) + 1;
        const endY = startY + Math.ceil(canvas.height / TILE_SIZE) + 1;
        
        for (let y = startY; y < endY; y++) {
            for (let x = startX; x < endX; x++) {
                const tileX = x * TILE_SIZE - camera.x;
                const tileY = y * TILE_SIZE - camera.y;
                const tileType = getTileType(x, y);
        
                ctx.fillStyle = getTileColor(tileType);
                ctx.fillRect(tileX, tileY, TILE_SIZE, TILE_SIZE);
        
                if (tileType === TILE_TYPES.FOREST) {
                    ctx.beginPath();
                    ctx.moveTo(tileX + TILE_SIZE / 2, tileY);
                    ctx.lineTo(tileX, tileY + TILE_SIZE);
                    ctx.lineTo(tileX + TILE_SIZE, tileY + TILE_SIZE);
                    ctx.fillStyle = '#006400';
                    ctx.fill();
                } else if (tileType === TILE_TYPES.ROCK) {
                    // Small impassable rock ðŸª¨
                    ctx.fillText('\u{1FAA8}', tileX, tileY + TILE_SIZE * 0.9);
                } else if (tileType === TILE_TYPES.MOUNTAIN_ROCK) {
                    // Climbable mountain rocks - shade based on elevation
                    const h = heightNoise(x, y);
                    // Normalise to mountain range
                    const normalised = (h - HEIGHT_MOUNTAIN_THRESHOLD) / (HEIGHT_SNOW_THRESHOLD - HEIGHT_MOUNTAIN_THRESHOLD);
                    // Higher = lighter (downhill easier), lower = darker (uphill harder)
                    // Keep rocks in grey range: 80-160 (clearly grey, not white)
                    const lightness = Math.floor(80 + normalised * 80); // Range: 80-160
                    ctx.fillStyle = `rgb(${lightness}, ${lightness}, ${lightness})`;
                    ctx.fillRect(tileX, tileY, TILE_SIZE, TILE_SIZE);
                } else if (tileType === TILE_TYPES.SNOW) {
                    // Snow - shade based on elevation
                    const h = heightNoise(x, y);
                    // Snow appears when h > HEIGHT_SNOW_THRESHOLD, range is threshold to 1.0
                    const snowRange = h - HEIGHT_SNOW_THRESHOLD;
                    const maxSnowRange = 1.0 - HEIGHT_SNOW_THRESHOLD;
                    const normalised = Math.max(0, Math.min(1, snowRange / maxSnowRange));
                    // Lower snow (uphill/harder) = antique white, higher (downhill/easier) = pure white
                    if (normalised < 0.5) {
                        // Lower elevations - antique white tint (FAEBD7)
                        ctx.fillStyle = '#FAEBD7'; // antique white
                    } else {
                        // Higher elevations - pure white
                        ctx.fillStyle = '#FFFFFF'; // pure white
                    }
                    ctx.fillRect(tileX, tileY, TILE_SIZE, TILE_SIZE);
                }
            }
        }

        boats.forEach(boat => {
            const boatX = boat.x - camera.x;
            const boatY = boat.y - camera.y;
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(boatX, boatY, TILE_SIZE, TILE_SIZE / 2);
            ctx.beginPath();
            ctx.moveTo(boatX, boatY + TILE_SIZE / 2);
            ctx.lineTo(boatX + TILE_SIZE / 2, boatY + TILE_SIZE);
            ctx.lineTo(boatX + TILE_SIZE, boatY + TILE_SIZE / 2);
            ctx.fill();
        });

        goldNuggets.forEach(gold => {
            const goldX = gold.x - camera.x;
            const goldY = gold.y - camera.y;
            ctx.fillStyle = 'gold';
            ctx.beginPath();
            ctx.arc(goldX + TILE_SIZE / 2, goldY + TILE_SIZE / 2, TILE_SIZE / 4, 0, 2 * Math.PI);
            ctx.fill();
        });

        ctx.font = `${TILE_SIZE}px Arial`;
        
        // Draw Fish (cull offscreen for perf)
        const vw = canvas.width, vh = canvas.height;
        fishFlock.forEach(animal => {
            const animalX = animal.x - camera.x;
            const animalY = animal.y - camera.y;
            if (animalX >= -TILE_SIZE && animalX <= vw + TILE_SIZE && animalY >= -TILE_SIZE && animalY <= vh + TILE_SIZE) {
                ctx.fillText('\u{1F41F}', animalX, animalY + TILE_SIZE);
            }
        });

        // Draw Land Animals
        landAnimals.forEach(animal => {
            const animalX = animal.x - camera.x;
            const animalY = animal.y - camera.y;
            
            // FIXME
            if (!(isAnimalTypeValid(animal.type)))  
                {
                animal.type=ANIMAL_TYPES[Math.floor(Math.random() * (ANIMAL_TYPES.length - 2))];
                
                //console.log("Animal born: "+animal.type);
                }
            ctx.fillText(animal.type, animalX, animalY + TILE_SIZE);
        });

        // Draw NPCs with overlaid legs
        measureExecutionTime('drawNPCs', drawNPCs);

        if (path && path.length > 0) {
            ctx.beginPath();
            ctx.moveTo(path[0].x - camera.x, path[0].y - camera.y);
            for (let i = 1; i < path.length; i++) {
                ctx.lineTo(path[i].x - camera.x, path[i].y - camera.y);
            }
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2;
            ctx.stroke();
        }
    });
}


function getTileColor(tileType) {
    const colors = [
        '#0077BE',  // DEEP_WATER
        '#89CFF0',  // SHALLOW_WATER
        '#F4A460',  // BEACH
        '#7CFC00',  // GRASS
        '#228B22',  // FOREST
        '#DEB887',  // DESERT
        '#808080',  // ROCK (small unclimbable rocks)
        '#4A4A4A',  // CITY_PAVED (dark grey)
        '#8B7355',  // TOWN_ROAD (brown cart road)
        '#6B5D52',  // VILLAGE_MUD (muddy brown)
        '#FFFAFA',  // SNOW (off-white snow peak)
        '#696969'   // MOUNTAIN_ROCK (dim grey, climbable mountains)
    ];
    return colors[tileType] || '#000000';
}

// Draw an emoji with simple overlaid legs using canvas lines
function drawEmojiWithLegs(emoji, worldX, worldY, sizePx, phase, options = {}) {
    const screenX = worldX - camera.x;
    const screenY = worldY - camera.y;
    // Draw the emoji
    ctx.save();
    ctx.font = `${sizePx}px Arial`;
    ctx.textBaseline = 'alphabetic';
    ctx.fillText(emoji, screenX, screenY + sizePx * 0.95);
    ctx.restore();

    // Draw stick legs beneath
    const legColour = options.legColour || '#222';
    const legLen = sizePx * 0.55;
    const hipX = screenX + sizePx * 0.5;
    const hipY = screenY + sizePx * 0.7;

    const swingAmp = (options.swingAmp ?? 0.25) * Math.PI; // radians
    const swingSpeed = options.swingSpeed ?? 2.0; // Hz-ish
    const t = performance.now() / 1000 * swingSpeed + (phase || 0);
    const aL = Math.sin(t) * swingAmp;
    const aR = Math.sin(t + Math.PI) * swingAmp;

    ctx.save();
    ctx.strokeStyle = legColour;
    ctx.lineWidth = Math.max(1, Math.floor(sizePx * 0.07));
    ctx.lineCap = 'round';

    // Left leg
    ctx.beginPath();
    ctx.moveTo(hipX - sizePx * 0.12, hipY);
    ctx.lineTo(hipX - sizePx * 0.12 + Math.sin(aL) * legLen * 0.3, hipY + Math.cos(aL) * legLen);
    ctx.stroke();

    // Right leg
    ctx.beginPath();
    ctx.moveTo(hipX + sizePx * 0.12, hipY);
    ctx.lineTo(hipX + sizePx * 0.12 + Math.sin(aR) * legLen * 0.3, hipY + Math.cos(aR) * legLen);
    ctx.stroke();
    ctx.restore();
}

function drawNPCs() {
    // Draw NPCs with legs and show speech on hover or proximity
    const size = TILE_SIZE * 1.2;
    const playerDist = 80; // show speech if player within this distance
    for (const n of npcs) {
        drawEmojiWithLegs(n.emoji, n.x, n.y, size, n.phase, { swingAmp: 0.15, swingSpeed: 1.5 });
        
        // Show name and speech bubble if player is close
        const d = distance(player.x, player.y, n.x, n.y);
        if (d < playerDist) {
            const screenX = n.x - camera.x;
            const screenY = n.y - camera.y;
            ctx.save();
            ctx.font = '10px Arial';
            ctx.fillStyle = 'rgba(0,0,0,0.8)';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'bottom';
            
            // Name above
            ctx.fillText(n.name, screenX + size * 0.5, screenY - size * 0.3);
            
            // Speech bubble below
            ctx.font = '9px Arial';
            ctx.fillStyle = 'rgba(255,255,255,0.95)';
            const bubbleY = screenY + size * 1.4;
            const textWidth = ctx.measureText(n.speech).width;
            ctx.fillRect(screenX + size * 0.5 - textWidth / 2 - 4, bubbleY - 12, textWidth + 8, 14);
            ctx.fillStyle = 'rgba(0,0,0,0.9)';
            ctx.fillText(n.speech, screenX + size * 0.5, bubbleY);
            ctx.restore();
        }
    }
}


function drawPlayer() {
    return measureExecutionTime('drawPlayer', () => {
            // Debug mode visualization
            if (debugMode) {
                const screenX = player.x - camera.x;
                const screenY = player.y - camera.y;
                
                // Draw player position as red crosshair
                ctx.strokeStyle = 'red';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(screenX - 10, screenY);
                ctx.lineTo(screenX + 10, screenY);
                ctx.moveTo(screenX, screenY - 10);
                ctx.lineTo(screenX, screenY + 10);
                ctx.stroke();
                
                // Draw tile center as green square
                const playerTileX = Math.floor(player.x / TILE_SIZE);
                const playerTileY = Math.floor(player.y / TILE_SIZE);
                const tileCenterX = playerTileX * TILE_SIZE + TILE_SIZE / 2 - camera.x;
                const tileCenterY = playerTileY * TILE_SIZE + TILE_SIZE / 2 - camera.y;
                
                ctx.strokeStyle = 'lime';
                ctx.lineWidth = 1;
                ctx.strokeRect(tileCenterX - 5, tileCenterY - 5, 10, 10);
                
                // Draw tile boundaries
                const tileScreenX = playerTileX * TILE_SIZE - camera.x;
                const tileScreenY = playerTileY * TILE_SIZE - camera.y;
                ctx.strokeStyle = 'yellow';
                ctx.lineWidth = 1;
                ctx.strokeRect(tileScreenX, tileScreenY, TILE_SIZE, TILE_SIZE);
            }
            
            ctx.save(); // Save the current canvas state
            ctx.font = `${player.size * 2}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            // Flip directional emojis when moving right (they face left by default)
            const shouldFlip = player.direction === 'right' && 
                              (player.currentEmoji === PLAYER_EMOJIS.WALKING || 
                               player.currentEmoji === PLAYER_EMOJIS.RUNNING ||
                               player.currentEmoji === PLAYER_EMOJIS.SWIMMING ||
                               player.currentEmoji === PLAYER_EMOJIS.SKIING ||
                               player.currentEmoji === PLAYER_EMOJIS.SNOWBOARDING ||
                               player.currentEmoji === PLAYER_EMOJIS.CLIMBING);
            
            if (shouldFlip) {
                ctx.scale(-1, 1); // Flip horizontally
                ctx.fillText(player.currentEmoji, -(player.x - camera.x), player.y - camera.y);
            } else {
                ctx.fillText(player.currentEmoji, player.x - camera.x, player.y - camera.y);
            }
            ctx.restore(); // Restore the canvas state
    });
}

function updatePlayerEmoji() {
    const currentTime = Date.now();
    if (currentTime - lastAnimationTime > ANIMATION_INTERVAL) {
        lastAnimationTime = currentTime;
        if (player.inBoat) {
            player.currentEmoji = PLAYER_EMOJIS.ROWING;
        } else if (player.isSwimming) {
            player.currentEmoji = PLAYER_EMOJIS.SWIMMING;
        } else if (player.isClimbing) {
            player.currentEmoji = PLAYER_EMOJIS.CLIMBING;
        } else if (player.isSkiing) {
            player.currentEmoji = PLAYER_EMOJIS.SKIING;
        } else if (player.isSnowboarding) {
            player.currentEmoji = PLAYER_EMOJIS.SNOWBOARDING;
        } else if (player.isMoving) {
            playerAnimationFrame = (playerAnimationFrame + 1) % 3;
            switch (playerAnimationFrame) {
                case 0:
                    player.currentEmoji = PLAYER_EMOJIS.WALKING;
                    break;
                case 1:
                    player.currentEmoji = PLAYER_EMOJIS.STANDING;
                    break;
                case 2:
                    player.currentEmoji = PLAYER_EMOJIS.RUNNING;
                    break;
            }
        } else {
            player.currentEmoji = PLAYER_EMOJIS.STANDING;
        }
    }
}

function updateUI() {
    return measureExecutionTime('updateUI', () => {
        const tileX = Math.floor(player.x / TILE_SIZE);
        const tileY = Math.floor(player.y / TILE_SIZE);
        const tileCenterX = tileX * TILE_SIZE + TILE_SIZE / 2;
        const tileCenterY = tileY * TILE_SIZE + TILE_SIZE / 2;
        
        if (debugMode) {
            const offsetX = (player.x - tileCenterX).toFixed(2);
            const offsetY = (player.y - tileCenterY).toFixed(2);
            xPosElement.textContent = `${tileX} (px: ${player.x.toFixed(1)}, offset: ${offsetX})`;
            yPosElement.textContent = `${tileY} (px: ${player.y.toFixed(1)}, offset: ${offsetY})`;
        } else {
            xPosElement.textContent = tileX;
            yPosElement.textContent = tileY;
        }
        
        const tileType = getTileType(tileX, tileY);
        biomeElement.textContent = getBiomeName(tileType);
        if ( player.inBoat ) {statusElement.textContent = 'In Boat' };
        statusElement.textContent = player.inBoat ? 'In Boat' : 'On Foot';
        if (debugMode) {
            statusElement.textContent += ' [DEBUG MODE]';
        }
        goldCountElement.textContent = player.gold;
    });
}

function getBiomeName(tileType) {
    const biomes = ['Deep Water', 'Shallow Water', 'Beach', 'Grassland', 'Forest', 'Desert', 'Rocky', 'City', 'Town', 'Village', 'Snow Peak'];
    return biomes[tileType] || 'Unknown';
}

function getTileType(x, y) {
    const chunkX = Math.floor(x / CHUNK_SIZE);
    const chunkY = Math.floor(y / CHUNK_SIZE);
    const chunkKey = `${chunkX},${chunkY}`;
    
    if (!chunks[chunkKey]) {
        chunks[chunkKey] = generateChunk(chunkX, chunkY);
        placeBoatsInChunk(chunkX, chunkY);
    }

    const localX = ((x % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
    const localY = ((y % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
    
    return chunks[chunkKey][localY][localX];
}

function drawMinimap() {
    return measureExecutionTime('drawMinimap', () => {
        minimapCtx.clearRect(0, 0, minimapCanvas.width, minimapCanvas.height);
        const scale = MINIMAP_SCALE;
        const offsetX = player.x * scale - minimapCanvas.width / 2;
        const offsetY = player.y * scale - minimapCanvas.height / 2;

        for (let chunkKey in chunks) {
            const [chunkX, chunkY] = chunkKey.split(',').map(Number);
            const chunk = chunks[chunkKey];

            for (let y = 0; y < CHUNK_SIZE; y++) {
                for (let x = 0; x < CHUNK_SIZE; x++) {
                    const worldX = (chunkX * CHUNK_SIZE + x) * TILE_SIZE;
                    const worldY = (chunkY * CHUNK_SIZE + y) * TILE_SIZE;
                    const tileType = chunk[y][x];
                    const tileColor = getTileColor(tileType);

                    minimapCtx.fillStyle = tileColor;
                    minimapCtx.fillRect(
                        (worldX * scale - offsetX),
                        (worldY * scale - offsetY),
                        TILE_SIZE * scale + 1,
                        TILE_SIZE * scale + 1
                    );
                }
            }
        }

        boats.forEach(boat => {
            minimapCtx.fillStyle = 'brown';
            minimapCtx.fillRect(
                boat.x * scale - offsetX,
                boat.y * scale - offsetY,
                4, 4
            );
        });

        goldNuggets.forEach(gold => {
            minimapCtx.fillStyle = 'gold';
            minimapCtx.fillRect(
                gold.x * scale - offsetX,
                gold.y * scale - offsetY,
                3, 3
            );
        });

        minimapCtx.fillStyle = 'red';
        minimapCtx.fillRect(
            minimapCanvas.width / 2 - 2,
            minimapCanvas.height / 2 - 2,
            4, 4
        );
    });
}

// Draw full world map
function drawWorldMap() {
    // Find bounds of all generated chunks
    let minChunkX = Infinity, maxChunkX = -Infinity;
    let minChunkY = Infinity, maxChunkY = -Infinity;
    
    for (const chunkKey in chunks) {
        const [cx, cy] = chunkKey.split(',').map(Number);
        minChunkX = Math.min(minChunkX, cx);
        maxChunkX = Math.max(maxChunkX, cx);
        minChunkY = Math.min(minChunkY, cy);
        maxChunkY = Math.max(maxChunkY, cy);
    }
    
    // If no chunks, use default area around player
    if (minChunkX === Infinity) {
        const playerChunkX = Math.floor(player.x / TILE_SIZE / CHUNK_SIZE);
        const playerChunkY = Math.floor(player.y / TILE_SIZE / CHUNK_SIZE);
        minChunkX = playerChunkX - 5;
        maxChunkX = playerChunkX + 5;
        minChunkY = playerChunkY - 5;
        maxChunkY = playerChunkY + 5;
    }
    
    // Convert to tile coordinates
    const minTileX = minChunkX * CHUNK_SIZE;
    const maxTileX = (maxChunkX + 1) * CHUNK_SIZE;
    const minTileY = minChunkY * CHUNK_SIZE;
    const maxTileY = (maxChunkY + 1) * CHUNK_SIZE;
    
    const worldWidthTiles = maxTileX - minTileX;
    const worldHeightTiles = maxTileY - minTileY;
    
    console.log(`Drawing world map: ${worldWidthTiles}x${worldHeightTiles} tiles (chunks ${minChunkX},${minChunkY} to ${maxChunkX},${maxChunkY})`);
    
    // Calculate max dimensions (89% of screen)
    const maxWidth = Math.floor(window.innerWidth * 0.89);
    const maxHeight = Math.floor(window.innerHeight * 0.89);
    
    // Calculate tile size to fit world within max dimensions
    const tilePixelSize = Math.min(
        maxWidth / worldWidthTiles,
        maxHeight / worldHeightTiles
    );
    
    console.log(`Tile pixel size: ${tilePixelSize}, Map size: ${worldWidthTiles * tilePixelSize}x${worldHeightTiles * tilePixelSize}`);
    
    // Calculate actual map size (fit to world data)
    const actualMapWidth = worldWidthTiles * tilePixelSize;
    const actualMapHeight = worldHeightTiles * tilePixelSize;
    
    // Resize canvas to actual needed size
    worldMapCanvas.width = actualMapWidth;
    worldMapCanvas.height = actualMapHeight;
    
    // Clear canvas
    worldMapCtx.fillStyle = '#000';
    worldMapCtx.fillRect(0, 0, actualMapWidth, actualMapHeight);
    
    // Draw all tiles in the generated area
    for (let y = minTileY; y < maxTileY; y++) {
        for (let x = minTileX; x < maxTileX; x++) {
            const tileType = getTileType(x, y);
            const tileColor = getTileColor(tileType);
            
            worldMapCtx.fillStyle = tileColor;
            worldMapCtx.fillRect(
                (x - minTileX) * tilePixelSize,
                (y - minTileY) * tilePixelSize,
                tilePixelSize + 1,
                tilePixelSize + 1
            );
        }
    }
    
    console.log(`World map drawn. Total chunks: ${Object.keys(chunks).length}`);
    
    // Draw player position as red circle
    const playerTileX = Math.floor(player.x / TILE_SIZE);
    const playerTileY = Math.floor(player.y / TILE_SIZE);
    const playerCenterX = (playerTileX - minTileX + 0.5) * tilePixelSize;
    const playerCenterY = (playerTileY - minTileY + 0.5) * tilePixelSize;
    
    console.log(`Player at tile (${playerTileX}, ${playerTileY}), pixel (${playerCenterX.toFixed(1)}, ${playerCenterY.toFixed(1)})`);
    
    // Draw red circle with white outline for visibility
    worldMapCtx.fillStyle = 'red';
    worldMapCtx.strokeStyle = 'white';
    worldMapCtx.lineWidth = 2;
    worldMapCtx.beginPath();
    worldMapCtx.arc(playerCenterX, playerCenterY, 6, 0, Math.PI * 2);
    worldMapCtx.fill();
    worldMapCtx.stroke();
    
    // Draw settlements
    if (settlements.city) {
        worldMapCtx.fillStyle = 'yellow';
        worldMapCtx.beginPath();
        worldMapCtx.arc(
            ((settlements.city.cx / TILE_SIZE) - minTileX) * tilePixelSize,
            ((settlements.city.cy / TILE_SIZE) - minTileY) * tilePixelSize,
            3,
            0,
            Math.PI * 2
        );
        worldMapCtx.fill();
    }
}

function drawMinimap() {
    return measureExecutionTime('drawMinimap', () => {
            minimapCtx.clearRect(0, 0, minimapCanvas.width, minimapCanvas.height);
            
            const minimapTileSize = TILE_SIZE * MINIMAP_SCALE;
            const visibleTilesX = Math.ceil(minimapCanvas.width / minimapTileSize);
            const visibleTilesY = Math.ceil(minimapCanvas.height / minimapTileSize);
            
            const centerX = Math.floor(minimapCanvas.width / (2 * minimapTileSize));
            const centerY = Math.floor(minimapCanvas.height / (2 * minimapTileSize));
            
            const startX = Math.floor(player.x / TILE_SIZE) - centerX;
            const startY = Math.floor(player.y / TILE_SIZE) - centerY;
            
            for (let y = 0; y < visibleTilesY; y++) {
                for (let x = 0; x < visibleTilesX; x++) {
                    const worldX = startX + x;
                    const worldY = startY + y;
                    const tileType = getTileType(worldX, worldY);
                    minimapCtx.fillStyle = getTileColor(tileType);
                    minimapCtx.fillRect(x * minimapTileSize, y * minimapTileSize, minimapTileSize, minimapTileSize);
                }
            }
        
        minimapCtx.fillStyle = 'red';
        minimapCtx.fillRect(centerX * minimapTileSize, centerY * minimapTileSize, minimapTileSize, minimapTileSize);
        
        minimapCtx.fillStyle = 'brown';
        boats.forEach(boat => {
            const boatMinimapX = (boat.x / TILE_SIZE - startX) * minimapTileSize;
            const boatMinimapY = (boat.y / TILE_SIZE - startY) * minimapTileSize;
            if (boatMinimapX >= 0 && boatMinimapX < minimapCanvas.width && boatMinimapY >= 0 && boatMinimapY < minimapCanvas.height) {
                minimapCtx.fillRect(boatMinimapX, boatMinimapY, minimapTileSize, minimapTileSize);
            }
        });
    
        minimapCtx.fillStyle = 'gold';
        goldNuggets.forEach(gold => {
            const goldMinimapX = (gold.x / TILE_SIZE - startX) * minimapTileSize;
            const goldMinimapY = (gold.y / TILE_SIZE - startY) * minimapTileSize;
            if (goldMinimapX >= 0 && goldMinimapX < minimapCanvas.width && goldMinimapY >= 0 && goldMinimapY < minimapCanvas.height) {
                minimapCtx.fillRect(goldMinimapX, goldMinimapY, minimapTileSize, minimapTileSize);
            }
        });
    });
}

// World map click handler
worldMapCanvas.addEventListener('click', async (event) => {
    if (!worldMapVisible) return;
    
    // Get click position relative to canvas BEFORE hiding it
    const rect = worldMapCanvas.getBoundingClientRect();
    const scaleX = worldMapCanvas.width / rect.width;
    const scaleY = worldMapCanvas.height / rect.height;
    const clickX = (event.clientX - rect.left) * scaleX;
    const clickY = (event.clientY - rect.top) * scaleY;
    
    // Close the world map immediately (after getting rect, before heavy calculations)
    worldMapVisible = false;
    gamePaused = false;
    worldMapCanvas.style.display = 'none';
    minimapCanvas.style.display = 'block';
    
    const chunkIterStart = performance.now();
    // Find bounds of all generated chunks (same as drawWorldMap)
    let minChunkX = Infinity, maxChunkX = -Infinity;
    let minChunkY = Infinity, maxChunkY = -Infinity;
    
    for (const chunkKey in chunks) {
        const [cx, cy] = chunkKey.split(',').map(Number);
        minChunkX = Math.min(minChunkX, cx);
        maxChunkX = Math.max(maxChunkX, cx);
        minChunkY = Math.min(minChunkY, cy);
        maxChunkY = Math.max(maxChunkY, cy);
    }
    const chunkIterEnd = performance.now();
    console.log(`Chunk iteration took ${(chunkIterEnd - chunkIterStart).toFixed(2)}ms for ${Object.keys(chunks).length} chunks`);
    
    if (minChunkX === Infinity) return; // No chunks yet
    
    // Convert to tile coordinates
    const minTileX = minChunkX * CHUNK_SIZE;
    const maxTileX = (maxChunkX + 1) * CHUNK_SIZE;
    const minTileY = minChunkY * CHUNK_SIZE;
    const maxTileY = (maxChunkY + 1) * CHUNK_SIZE;
    
    const worldWidthTiles = maxTileX - minTileX;
    const worldHeightTiles = maxTileY - minTileY;
    
    // Use actual canvas size (which was set by drawWorldMap)
    const canvasWidth = worldMapCanvas.width;
    const canvasHeight = worldMapCanvas.height;
    
    if (canvasWidth <= 0 || canvasHeight <= 0) {
        console.log('Invalid canvas size');
        return;
    }
    
    // Calculate tile size from actual canvas dimensions
    const tilePixelSizeX = canvasWidth / worldWidthTiles;
    const tilePixelSizeY = canvasHeight / worldHeightTiles;
    
    if (!tilePixelSizeX || tilePixelSizeX <= 0 || !tilePixelSizeY || tilePixelSizeY <= 0) {
        console.log('Invalid tile pixel size');
        return;
    }
    
    // Convert click to world tile coordinates using actual canvas mapping
    const worldTileX = Math.floor(clickX / tilePixelSizeX) + minTileX;
    const worldTileY = Math.floor(clickY / tilePixelSizeY) + minTileY;
    
    // Convert to pixel coordinates (centered in tile)
    const worldX = worldTileX * TILE_SIZE + TILE_SIZE / 2;
    const worldY = worldTileY * TILE_SIZE + TILE_SIZE / 2;
    
    console.log(`World map click: tile (${worldTileX}, ${worldTileY}), world pos (${worldX}, ${worldY})`);
    
    // Set path to this location
    target = { x: worldX, y: worldY };
    const pathStartTime = performance.now();
    path = findPath(player.x, player.y, worldX, worldY, undefined, MAX_SEARCH_DISTANCE, true); // true = simple mode (no height checks)
    const pathEndTime = performance.now();
    console.log(`Pathfinding took ${(pathEndTime - pathStartTime).toFixed(2)}ms, path found: ${path !== null}, path length: ${path ? path.length : 0}`);
});

// Minimap click handler
minimapCanvas.addEventListener('click', async (event) => {
    if (worldMapVisible) return; // Don't handle clicks when world map is open
    
    // Get click position relative to canvas
    const rect = minimapCanvas.getBoundingClientRect();
    const scaleX = minimapCanvas.width / rect.width;
    const scaleY = minimapCanvas.height / rect.height;
    const clickX = (event.clientX - rect.left) * scaleX;
    const clickY = (event.clientY - rect.top) * scaleY;
    
    // Calculate minimap scale (MUST match drawMinimap)
    const minimapTileSize = TILE_SIZE * MINIMAP_SCALE;
    const visibleTilesX = Math.ceil(minimapCanvas.width / minimapTileSize);
    const visibleTilesY = Math.ceil(minimapCanvas.height / minimapTileSize);
    
    const centerX = Math.floor(minimapCanvas.width / (2 * minimapTileSize));
    const centerY = Math.floor(minimapCanvas.height / (2 * minimapTileSize));
    
    const startX = Math.floor(player.x / TILE_SIZE) - centerX;
    const startY = Math.floor(player.y / TILE_SIZE) - centerY;
    
    // Convert minimap click to world tile coordinates (match drawMinimap logic)
    const clickTileX = Math.floor(clickX / minimapTileSize);
    const clickTileY = Math.floor(clickY / minimapTileSize);
    
    const worldTileX = startX + clickTileX;
    const worldTileY = startY + clickTileY;
    
    // Convert to pixel coordinates (centered in tile)
    const worldX = worldTileX * TILE_SIZE + TILE_SIZE / 2;
    const worldY = worldTileY * TILE_SIZE + TILE_SIZE / 2;
    
    console.log(`Minimap click: tile (${worldTileX}, ${worldTileY}), world pos (${worldX}, ${worldY})`);
    
    // Set path to this location
    target = { x: worldX, y: worldY };
    path = findPath(player.x, player.y, worldX, worldY, undefined, MAX_SEARCH_DISTANCE);
});

function isWalkable(x, y, inBoat, isFish) {
    const tileType = getTileType(Math.floor(x / TILE_SIZE), Math.floor(y / TILE_SIZE));
    if (isFish !== undefined) {  // For animals
        return isFish ? tileType === TILE_TYPES.DEEP_WATER : (tileType !== TILE_TYPES.DEEP_WATER && tileType !== TILE_TYPES.SHALLOW_WATER && tileType !== TILE_TYPES.ROCK && tileType !== TILE_TYPES.SNOW && tileType !== TILE_TYPES.MOUNTAIN_ROCK);
    }
    // For player
    if (inBoat) {
        return tileType === TILE_TYPES.DEEP_WATER || tileType === TILE_TYPES.SHALLOW_WATER || tileType === TILE_TYPES.BEACH;
    } else {
        // Player can walk on normal terrain but NOT on small rocks (ROCK). MOUNTAIN_ROCK and SNOW are handled by pathfinding with special movement
        return tileType !== TILE_TYPES.DEEP_WATER && tileType !== TILE_TYPES.SHALLOW_WATER && tileType !== TILE_TYPES.ROCK;
    }
}

// Common helpers (shared by land animals and fish)
function clampToWorldPos(x, y) {
    const maxX = WORLD_WIDTH * TILE_SIZE;
    const maxY = WORLD_HEIGHT * TILE_SIZE;
    return {
        x: Math.max(0, Math.min(x, maxX)),
        y: Math.max(0, Math.min(y, maxY))
    };
}

function easeScalar(current, target, dt, ratePerSecond) {
    const t = Math.min(1, Math.max(0, dt * ratePerSecond));
    return current + (target - current) * t;
}

function isWalkableLand(x, y) {
    return isWalkable(x, y, false, false);
}

function pickLocalWaypoint(startX, startY, rangeTiles, isWalkableFn, maxAttempts = 20) {
    const range = rangeTiles * TILE_SIZE;
    for (let i = 0; i < maxAttempts; i++) {
        const a = Math.random() * Math.PI * 2;
        const d = (0.5 + Math.random()) * range; // bias away from zero
        let wx = startX + Math.cos(a) * d;
        let wy = startY + Math.sin(a) * d;
        const c = clampToWorldPos(wx, wy);
        wx = c.x; wy = c.y;
        if (isWalkableFn(wx, wy)) return { x: wx, y: wy };
    }
    return null;
}

function distance(x1, y1, x2, y2) {
    const dx = x2 - x1, dy = y2 - y1;
    return Math.hypot(dx, dy);
}

function direction(x1, y1, x2, y2) {
    const dx = x2 - x1, dy = y2 - y1;
    const d = Math.hypot(dx, dy);
    if (d === 0) return { x: 0, y: 0, d: 0 };
    return { x: dx / d, y: dy / d, d };
}


function findPath(startX, startY, endX, endY, isFish, maxSearchDistance = MAX_SEARCH_DISTANCE, simpleMode = false) {
    // Snap start and end to tile grid (top-left corners for pathfinding)
    const startTileX = Math.floor(startX / TILE_SIZE) * TILE_SIZE;
    const startTileY = Math.floor(startY / TILE_SIZE) * TILE_SIZE;
    const endTileX = Math.floor(endX / TILE_SIZE) * TILE_SIZE;
    const endTileY = Math.floor(endY / TILE_SIZE) * TILE_SIZE;
    
    // Reuse pooled height cache (clear instead of new Map())
    pathfindingHeightCache.clear();
    const getHeight = (tileX, tileY) => {
        const key = `${tileX},${tileY}`;
        if (!pathfindingHeightCache.has(key)) {
            pathfindingHeightCache.set(key, heightNoise(tileX, tileY));
        }
        return pathfindingHeightCache.get(key);
    };
    
    // Reuse pooled heap and closedSet (clear instead of new)
    pathfindingHeap.clear();
    pathfindingClosedSet.clear();
    const start = {x: startTileX, y: startTileY, f: 0, g: 0, h: 0, parent: null, inBoat: isFish === undefined ? player.inBoat : undefined, isSwimming: isFish === undefined ? player.isSwimming : false, isClimbing: isFish === undefined ? player.isClimbing : false, isSkiing: isFish === undefined ? player.isSkiing : false, isSnowboarding: isFish === undefined ? player.isSnowboarding : false};
    const end = {x: endTileX, y: endTileY};

    pathfindingHeap.push(start);
    
    let nodesExplored = 0;

    while (pathfindingHeap.size() > 0) {
        const current = pathfindingHeap.pop();
        nodesExplored++;

        // Check if we've exceeded the maximum search distance
        if (Math.abs(current.x - startTileX) > maxSearchDistance || Math.abs(current.y - startTileY) > maxSearchDistance) {
            console.log(`Max search distance exceeded after ${nodesExplored} nodes`);
            return null;
        }

        if (Math.abs(current.x - end.x) < TILE_SIZE && Math.abs(current.y - end.y) < TILE_SIZE) {
            console.log(`Path found after exploring ${nodesExplored} nodes`);
            let path = [];
            let temp = current;
            while (temp) {
                // Center the waypoint in the tile
                path.push({
                    x: temp.x + TILE_SIZE / 2, 
                    y: temp.y + TILE_SIZE / 2, 
                    inBoat: temp.inBoat,
                    isSwimming: temp.isSwimming || false,
                    isClimbing: temp.isClimbing || false,
                    isSkiing: temp.isSkiing || false,
                    isSnowboarding: temp.isSnowboarding || false
                });
                temp = temp.parent;
            }
            return path.reverse();
        }

        pathfindingClosedSet.add(`${current.x},${current.y},${current.inBoat},${current.isSwimming || false},${current.isClimbing || false},${current.isSkiing || false},${current.isSnowboarding || false}`);

        const neighbors = [
            {dx: -TILE_SIZE, dy: 0},
            {dx: TILE_SIZE, dy: 0},
            {dx: 0, dy: -TILE_SIZE},
            {dx: 0, dy: TILE_SIZE},
            {dx: -TILE_SIZE, dy: -TILE_SIZE},
            {dx: -TILE_SIZE, dy: TILE_SIZE},
            {dx: TILE_SIZE, dy: -TILE_SIZE},
            {dx: TILE_SIZE, dy: TILE_SIZE}
        ];

        for (const {dx, dy} of neighbors) {
            const neighborX = current.x + dx;
            const neighborY = current.y + dy;
            
            // Check if neighbor is within max search distance
            if (Math.abs(neighborX - startX) > maxSearchDistance || Math.abs(neighborY - startY) > maxSearchDistance) {
                continue;
            }

            const neighborTileType = getTileType(Math.floor(neighborX / TILE_SIZE), Math.floor(neighborY / TILE_SIZE));
            const currentTileType = getTileType(Math.floor(current.x / TILE_SIZE), Math.floor(current.y / TILE_SIZE));

            let inBoat = current.inBoat;
            let isSwimming = current.isSwimming || false;
            let isClimbing = current.isClimbing || false;
            let isSkiing = current.isSkiing || false;
            let isSnowboarding = current.isSnowboarding || false;
            let canMove = isWalkable(neighborX, neighborY, inBoat, isFish);
            let moveCost = 1.0; // Base cost multiplier

            // Handle water transitions
            if (!canMove && !isFish && !inBoat && (neighborTileType === TILE_TYPES.DEEP_WATER || neighborTileType === TILE_TYPES.SHALLOW_WATER)) {
                const nearbyBoat = boats.find(boat => 
                    Math.abs(boat.x - current.x) <= TILE_SIZE && Math.abs(boat.y - current.y) <= TILE_SIZE
                );
                if (nearbyBoat) {
                    inBoat = true;
                    isSwimming = false;
                    canMove = true;
                } else {
                    // Can swim as last resort
                    isSwimming = true;
                    canMove = true;
                    moveCost = SWIMMING_PATHFINDING_COST; // Swimming is much less preferred
                }
            } else if (inBoat && neighborTileType !== TILE_TYPES.DEEP_WATER && neighborTileType !== TILE_TYPES.SHALLOW_WATER) {
                inBoat = false;
                isSwimming = false;
                // Re-check if we can walk on this tile when not in boat
                canMove = isWalkable(neighborX, neighborY, inBoat, isFish);
            } else if (isSwimming && neighborTileType !== TILE_TYPES.DEEP_WATER && neighborTileType !== TILE_TYPES.SHALLOW_WATER) {
                // Transitioning from swimming to land
                isSwimming = false;
                canMove = isWalkable(neighborX, neighborY, false, isFish);
            }
            
            // Handle mountain climbing
            if (!isFish && neighborTileType === TILE_TYPES.MOUNTAIN_ROCK) {
                isClimbing = true;
                isSkiing = false;
                isSnowboarding = false;
                canMove = true;
                moveCost = 25.0; // 25x slower than walking
            } else if (isClimbing && neighborTileType !== TILE_TYPES.MOUNTAIN_ROCK) {
                isClimbing = false;
            }
            
            // Handle snow movement
            if (!isFish && neighborTileType === TILE_TYPES.SNOW) {
                if (simpleMode) {
                    // Simple mode: skip height checks, assume ascending (snowboarding)
                    isSnowboarding = true;
                    isSkiing = false;
                    isClimbing = false;
                    canMove = true;
                    moveCost = 20.0; // 20x slower than walking
                } else {
                    // Determine if descending or ascending based on height
                    const currentTileX = Math.floor(current.x / TILE_SIZE);
                    const currentTileY = Math.floor(current.y / TILE_SIZE);
                    const neighborTileX = Math.floor(neighborX / TILE_SIZE);
                    const neighborTileY = Math.floor(neighborY / TILE_SIZE);
                    
                    const currentH = getHeight(currentTileX, currentTileY);
                    const neighborH = getHeight(neighborTileX, neighborTileY);
                    
                    if (neighborH < currentH) {
                        // Descending - skiing
                        isSkiing = true;
                        isSnowboarding = false;
                        isClimbing = false;
                        moveCost = 2.0; // 2x slower than walking
                    } else {
                        // Ascending - snowboarding
                        isSnowboarding = true;
                        isSkiing = false;
                        isClimbing = false;
                        moveCost = 20.0; // 20x slower than walking
                    }
                    canMove = true;
                }
            } else if ((isSkiing || isSnowboarding) && neighborTileType !== TILE_TYPES.SNOW) {
                isSkiing = false;
                isSnowboarding = false;
            }

            if (!canMove) continue;

            // For diagonal movement, check that we can move through the adjacent tiles (prevent cutting corners through rocks)
            if (dx !== 0 && dy !== 0) {
                const intermediateX = current.x + dx;
                const intermediateY = current.y + dy;
                const checkX = isWalkable(intermediateX, current.y, current.inBoat, isFish);
                const checkY = isWalkable(current.x, intermediateY, current.inBoat, isFish);
                // Both adjacent tiles must be walkable to allow diagonal movement
                if (!checkX || !checkY) continue;
            }

            const neighbor = {
                x: neighborX,
                y: neighborY,
                g: current.g + Math.sqrt(dx * dx + dy * dy) * moveCost,
                h: Math.abs(neighborX - end.x) + Math.abs(neighborY - end.y),
                parent: current,
                inBoat: inBoat,
                isSwimming: isSwimming,
                isClimbing: isClimbing,
                isSkiing: isSkiing,
                isSnowboarding: isSnowboarding
            };
            neighbor.f = neighbor.g + neighbor.h;

            const neighborKey = `${neighbor.x},${neighbor.y},${neighbor.inBoat},${neighbor.isSwimming},${neighbor.isClimbing},${neighbor.isSkiing},${neighbor.isSnowboarding}`;
            if (pathfindingClosedSet.has(neighborKey)) continue;

            if (!pathfindingHeap.contains(neighbor)) {
                pathfindingHeap.push(neighbor);
            } else {
                const existing = pathfindingHeap.getNode(neighbor);
                if (existing && neighbor.g < existing.g) {
                    // Update and re-heapify
                    pathfindingHeap.updateNode(existing, neighbor);
                }
            }
        }
    }

    console.log(`No path found after exploring ${nodesExplored} nodes, openSet exhausted`);
    return null;
}


async function transportToNearestBeach() {
    const searchRadius = 20;
    let nearestBeach = null;
    let minDistance = Infinity;

    for (let dy = -searchRadius; dy <= searchRadius; dy++) {
        for (let dx = -searchRadius; dx <= searchRadius; dx++) {
            const x = Math.floor(player.x / TILE_SIZE) + dx;
            const y = Math.floor(player.y / TILE_SIZE) + dy;
            if (getTileType(x, y) === TILE_TYPES.BEACH) {
                const distance = dx * dx + dy * dy;
                if (distance < minDistance) {
                    minDistance = distance;
                    nearestBeach = {x, y};
                }
            }
        }
    }

    if (nearestBeach) {
        player.x = (nearestBeach.x + 0.5) * TILE_SIZE;
        player.y = (nearestBeach.y + 0.5) * TILE_SIZE;
        player.inBoat = false;
        statusElement.textContent = 'Transported to Beach';
        await loadNewArea();
    } else {
        console.log('No nearby beach found');
    }
}

function dismountFromBoat() {
    player.inBoat = false;
    const nearestBeach = findNearestBeaches(player.x, player.y);
    if (nearestBeach) {
        boats.push({x: nearestBeach.x, y: nearestBeach.y});
    } //else {
      //  boats.push({x: player.x, y: player.y}); // Fallback if no shore is found
    //}
    statusElement.textContent = 'Dismounted from Boat';
}

function collectGold() {
    for (let i = goldNuggets.length - 1; i >= 0; i--) {
        const dx = goldNuggets[i].x - player.x;
        const dy = goldNuggets[i].y - player.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance <= GOLD_PICKUP_RADIUS) {
            player.gold++;
            
            // Create an animated emoji
            animatedEmojis.push({
                x: goldNuggets[i].x,
                y: goldNuggets[i].y,
                vy: -2,  // Vertical velocity (moving upwards)
                opacity: 1,
                createdAt: Date.now()
            });
            
            goldNuggets.splice(i, 1);
            statusElement.textContent = "Found gold";
            updateUI();
        }
    }
}

function updateAndRenderAnimatedEmojis() {
    const currentTime = Date.now();
    
    for (let i = animatedEmojis.length - 1; i >= 0; i--) {
        const emoji = animatedEmojis[i];
        
        // Update position and opacity
        emoji.y += emoji.vy;
        emoji.opacity = 1 - (currentTime - emoji.createdAt) / 1000;  // Fade out over 1 second
        
        // Remove if fully faded
        if (emoji.opacity <= 0) {
            animatedEmojis.splice(i, 1);
            continue;
        }
        
        // Render emoji
        const screenX = emoji.x - camera.x;
        const screenY = emoji.y - camera.y;
        
        ctx.font = `${TILE_SIZE}px Arial`;
        //ctx.textAlign = 'center';
        //ctx.textBaseline = 'middle';
        ctx.globalAlpha = emoji.opacity;
        ctx.fillText('\u{1FA99}', screenX + TILE_SIZE / 2, screenY + TILE_SIZE / 2);
        ctx.globalAlpha = 1;  // Reset global alpha
    }
}

function moveAnimals() {
    return measureExecutionTime('moveAnimals', () => {
        const currentTime = Date.now();

        // Reuse pooled arrays (clear instead of creating new)
        nearAnimalsPool.length = 0;
        farAnimalsPool.length = 0;
        
        for (const animal of landAnimals) {
            const d = distance(player.x, player.y, animal.x, animal.y);
            if (d <= MAX_ANIMAL_SEARCH_DISTANCE) {
                nearAnimalsPool.push({ animal, d });
            } else {
                farAnimalsPool.push(animal);
            }
        }

        // Sort near animals by ascending distance so closest consume budget first
        nearAnimalsPool.sort((a, b) => a.d - b.d);

        for (const item of nearAnimalsPool) {
            const a = item.animal;
            if (typeof a.update === 'function') a.update(currentTime);
        }

        // Keep far animals cheap
        for (const a of farAnimalsPool) {
            if (a.path && a.path.length > 0) a.path.length = 0; // Clear array instead of replacing
        }
    });
}

function generateRandomPath() {
    const maxDistance = 200 * TILE_SIZE; // Maximum distance for random path
    let targetX, targetY;
    let attempts = 0;
    const maxAttempts = 20;
    
    // Function to calculate distance between two points
    const distance = (x1, y1, x2, y2) => Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
    
    // Find nearby POIs (animals and gold) - avoid spread operator and filter
    const nearbyPOIs = [];
    for (const poi of landAnimals) {
        if (distance(player.x, player.y, poi.x, poi.y) <= maxDistance) nearbyPOIs.push(poi);
    }
    for (const poi of fishFlock) {
        if (distance(player.x, player.y, poi.x, poi.y) <= maxDistance) nearbyPOIs.push(poi);
    }
    for (const poi of goldNuggets) {
        if (distance(player.x, player.y, poi.x, poi.y) <= maxDistance) nearbyPOIs.push(poi);
    }
    
    do {
    // Prioritise POIs if available
        if (nearbyPOIs.length > 0 && Math.random() < 0.3) { // 30% chance to target a POI
            const targetPOI = nearbyPOIs[Math.floor(Math.random() * nearbyPOIs.length)];
            targetX = targetPOI.x;
            targetY = targetPOI.y;
        } else {
            // Generate random target if no POI is chosen
            const angle = Math.random() * 2 * Math.PI;
            const randomDistance = ((Math.random() * 2) - 1) * maxDistance ;
            targetX = player.x + randomDistance * Math.cos(angle);
            targetY = player.y + randomDistance * Math.sin(angle);
        }
        
        // Ensure the target is within the world bounds
        //targetX = Math.max(0, Math.min(targetX, WORLD_WIDTH * 4 * TILE_SIZE ));
        //targetY = Math.max(0, Math.min(targetY, WORLD_HEIGHT * 4 * TILE_SIZE  ));
        
        // Check if the target is walkable
        const targetTileX = Math.floor(targetX / TILE_SIZE);
        const targetTileY = Math.floor(targetY / TILE_SIZE);
        const isWalkableTarget = isWalkable(targetX, targetY, player.inBoat);
        
        // Only try to find a path if the target is walkable
        if (isWalkableTarget) {
            path = findPath(player.x, player.y, targetX, targetY, undefined, MAX_SEARCH_DISTANCE);
        } else {
            path = null;
        }
        
        attempts++;
    } while (!path && attempts < maxAttempts);
    
    if (path) {
        target = {x: targetX, y: targetY};
        //console.log('Generated path to POI or random location at '+ target.x+ ', ' +target.y);
        
        // Determine what kind of target we've found
        const targetType = landAnimals.some(animal => animal.x === targetX && animal.y === targetY) ? 'animal' :
                            goldNuggets.some(gold => gold.x === targetX && gold.y === targetY) ? 'gold' : 'random';
        
        // Update status message
        switch(targetType) {
            case 'animal':
                planElement.textContent = 'Moving towards an animal';
                break;
            case 'gold':
                planElement.textContent = 'Moving towards gold';
                break;
            default:
                planElement.textContent = 'Exploring randomly';
        }
    } else {
        console.log('Failed to generate a valid path');
        statusElement.textContent = 'Unable to find a valid path';
    }
}
async function movePlayer() {
    return await measureExecutionTime('movePlayer', async () => {
        if ((path && path.length > 0) || player.currentPathStep) {
            player.isMoving = true;
            
            // Time-based movement
            const now = Date.now();
            if (player.lastMoveTime === 0) player.lastMoveTime = now;
            const dt = (now - player.lastMoveTime) / 1000; // delta time in seconds
            player.lastMoveTime = now;
            
            // If we don't have a current target step, get the next one
            if (!player.currentPathStep && path && path.length > 0) {
                player.currentPathStep = path.shift();
                player.targetX = player.currentPathStep.x;
                player.targetY = player.currentPathStep.y;
            }
            
            // Smoothly interpolate towards the target position
            if (player.currentPathStep) {
                const dx = player.targetX - player.x;
                const dy = player.targetY - player.y;
                const distanceToTarget = Math.sqrt(dx * dx + dy * dy);
                
                // Update player direction based on movement
                if (Math.abs(dx) > 0.1) {
                    player.direction = dx > 0 ? 'right' : 'left';
                }
                
                if (distanceToTarget > 1.0) {
                    // Determine current speed based on movement state
                    let speedMultiplier = 1.0;
                    if (player.isSwimming) speedMultiplier = SWIMMING_SPEED_MULTIPLIER;
                    else if (player.isClimbing) speedMultiplier = 1.0 / 25.0; // 25x slower
                    else if (player.isSnowboarding) speedMultiplier = 1.0 / 20.0; // 20x slower
                    else if (player.isSkiing) speedMultiplier = 1.0 / 2.0; // 2x slower
                    
                    const currentSpeed = PLAYER_SPEED * speedMultiplier;
                    
                    // Move towards target at appropriate speed
                    const moveDistance = Math.min(currentSpeed * dt, distanceToTarget);
                    const ratio = moveDistance / distanceToTarget;
                    
                    player.x += dx * ratio;
                    player.y += dy * ratio;
                } else {
                    // Snap to exact target position when very close
                    const prevInBoat = player.inBoat;
                    const prevSwimming = player.isSwimming;
                    player.x = player.currentPathStep.x;
                    player.y = player.currentPathStep.y;
                    player.inBoat = player.currentPathStep.inBoat;
                    player.isSwimming = player.currentPathStep.isSwimming || false;
                    player.isClimbing = player.currentPathStep.isClimbing || false;
                    player.isSkiing = player.currentPathStep.isSkiing || false;
                    player.isSnowboarding = player.currentPathStep.isSnowboarding || false;
                    
                    if (player.currentPathStep.inBoat) {
                        boats.pop({x: player.x, y: player.y});
                    }
                    
                    const currentTileType = getTileType(Math.floor(player.x / TILE_SIZE), Math.floor(player.y / TILE_SIZE));
                    
                    // Only transport to beach if not swimming and not in boat
                    if (!player.inBoat && !player.isSwimming && (currentTileType === TILE_TYPES.DEEP_WATER || currentTileType === TILE_TYPES.SHALLOW_WATER)) {
                        await transportToNearestBeach();
                    }
                    
                    if (prevInBoat && !player.inBoat) {
                        dismountFromBoat();
                    }
                    
                    // Move to next step
                    player.currentPathStep = null;
                    
                    if (!path || path.length === 0) {
                        player.isMoving = false;
                        target = null;
                        lastPathCompletionTime = Date.now();
                        player.distanceTravelled = 0;
                        
                        // Clear movement states when path completes
                        player.isSwimming = false;
                        player.isClimbing = false;
                        player.isSkiing = false;
                        player.isSnowboarding = false;
                    }
                }
            }
            
            // Smooth camera follow
            camera.x = player.x - canvas.width / 2;
            camera.y = player.y - canvas.height / 2;

            collectGold();

            const playerChunkX = Math.floor(player.x / (CHUNK_SIZE * TILE_SIZE));
            const playerChunkY = Math.floor(player.y / (CHUNK_SIZE * TILE_SIZE));
            if (!chunks[`${playerChunkX},${playerChunkY}`]) {
                await loadNewArea();
            }
        } else {
            player.isMoving = false;
            player.lastMoveTime = 0;
            player.currentPathStep = null;
            
            // Check if it's time to generate a random path
            if (Date.now() - lastPathCompletionTime > AUTO_PATH_DELAY && !target) {
                generateRandomPath();
            }
        }

        // Update player emoji based on state
        if (player.inBoat) {
            player.currentEmoji = PLAYER_EMOJIS.ROWING;
        } else if (player.isMoving) {
            // This will be handled in updatePlayerEmoji function for animation
        } else {
            player.currentEmoji = PLAYER_EMOJIS.STANDING;
        }
    });
}

// ============================================================================
// CENTRALISED GAME LOOP ARCHITECTURE
// ============================================================================
// The game loop is structured with clear separation of concerns:
//
// update(dt):  All game state changes (player movement, NPC AI, physics)
//              Uses delta-time (dt) for frame-rate independent updates
//
// render():    All drawing operations (world, entities, UI)
//              Pure rendering - no state changes
//
// gameLoop():  Main scheduler running at ~60 FPS via requestAnimationFrame
//              Coordinates update â†’ render â†’ debug cycles
//
// This architecture prevents:
// - Stuttering from inconsistent update timing
// - Movement speed varying with frame rate
// - Ad-hoc function calls scattered across the codebase
// ============================================================================

// Centralised update function - all game state changes happen here
async function update(dt) {
    // Only update game state when not paused
    if (gamePaused) return;
    
    // Update player emoji animation
    measureExecutionTime('updatePlayerEmoji', updatePlayerEmoji);
    
    // Update player movement
    await measureExecutionTime('movePlayer', movePlayer);
    
    // Update NPCs
    measureExecutionTime('moveFish', moveFish);
    
    // Reset animal pathfinding slots for this frame before moving animals
    animalPathfindSlots = animalPathfindBudgetPerFrame;
    measureExecutionTime('moveAnimals', moveAnimals);
    
    // Update UI state
    measureExecutionTime('updateUI', updateUI);
}

// Centralised render function - all drawing happens here
function render() {
    // Clear canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Render world
    measureExecutionTime('drawWorld', drawWorld);
    
    // Render animated emojis
    updateAndRenderAnimatedEmojis();
    
    // Render NPCs
    measureExecutionTime('drawNPCs', drawNPCs);
    
    // Render player
    measureExecutionTime('drawPlayer', drawPlayer);
    
    // Render minimap
    measureExecutionTime('drawMinimap', drawMinimap);
}

// Main game loop with fixed timestep and delta-time integration
async function gameLoop() {
    const currentTime = performance.now();
    let deltaTime = (currentTime - lastFrameTime) / 1000; // Convert to seconds
    lastFrameTime = currentTime;
    
    // Cap delta time to prevent spiral of death
    deltaTime = Math.min(deltaTime, MAX_DELTA_TIME);
    
    frameCount++;
    totalFrameTime += deltaTime * 1000;
    
    // Update game state with delta time
    await update(deltaTime);
    
    // Render current state
    render();
    
    // Draw debug info
    drawDebugInfo(deltaTime * 1000);

    requestAnimationFrame(gameLoop);
}


function drawDebugInfo(frameTime) {
    ctx.font = '12px Arial';
    ctx.fillStyle = 'white';
    ctx.textAlign = 'left';
    ctx.textBaseline = 'bottom';

    let yOffset = 20;
    const lineHeight = 15;

    ctx.fillText(`Frame Time: ${frameTime.toFixed(2)}ms`, 10, canvas.height - yOffset);
    yOffset += lineHeight;

    if (frameCount >= 60) {
        const avgFrameTime = totalFrameTime / frameCount;
        const percent = (avgFrameTime / 16.67) * 100; // Assuming 60 FPS (1000ms/60 Ã¢â€°Ë† 16.67ms per frame)
        ctx.fillText(`Avg Frame Time: ${avgFrameTime.toFixed(2)}ms (${percent.toFixed(2)}% of 16.67ms)`, 10, canvas.height - yOffset);
        yOffset += lineHeight;

        // Reset total frame time and frame count every 60 frames
        totalFrameTime = 0;
        frameCount = 0;
    }

    for (const [methodName, times] of Object.entries(methodTimes)) {
        if (times.length > 0) {
            const avgTime = times.reduce((a, b) => a + b, 0) / times.length;
            const percent = (avgTime / frameTime) * 100;
            ctx.fillText(`${methodName}: ${avgTime.toFixed(2)}ms (${percent.toFixed(2)}%)`, 10, canvas.height - yOffset);
            yOffset += lineHeight;
        }
    }
}

function measureExecutionTime(methodName, method) {
    const start = performance.now();
    method();
    const end = performance.now();

    if (!methodTimes[methodName]) {
        methodTimes[methodName] = [];
    }
    methodTimes[methodName].push(end - start);

    // Keep only the last 60 frames of data for each method
    if (methodTimes[methodName].length > 60) {
        methodTimes[methodName].shift();
    }
}

// Find the largest landmass (continent) for the city placement
function findLargestContinent() {
    const visited = new Set();
    let largestSize = 0;
    let largestCentre = null;

    function floodFill(sx, sy) {
        const stack = [{x: sx, y: sy}];
        const tiles = [];
        while (stack.length > 0) {
            const {x, y} = stack.pop();
            const key = `${x},${y}`;
            if (visited.has(key)) continue;
            const tType = getTileType(x, y);
            if (tType === TILE_TYPES.DEEP_WATER || tType === TILE_TYPES.SHALLOW_WATER) continue;
            visited.add(key);
            tiles.push({x, y});
            for (const [dx, dy] of [[-1,0],[1,0],[0,-1],[0,1]]) {
                const nx = x + dx, ny = y + dy;
                if (nx >= 0 && nx < WORLD_WIDTH && ny >= 0 && ny < WORLD_HEIGHT) {
                    stack.push({x: nx, y: ny});
                }
            }
        }
        return tiles;
    }

    for (let y = 0; y < WORLD_HEIGHT; y += 5) {
        for (let x = 0; x < WORLD_WIDTH; x += 5) {
            const key = `${x},${y}`;
            if (visited.has(key)) continue;
            const tType = getTileType(x, y);
            if (tType !== TILE_TYPES.DEEP_WATER && tType !== TILE_TYPES.SHALLOW_WATER) {
                const tiles = floodFill(x, y);
                if (tiles.length > largestSize) {
                    largestSize = tiles.length;
                    const sumX = tiles.reduce((s, t) => s + t.x, 0);
                    const sumY = tiles.reduce((s, t) => s + t.y, 0);
                    largestCentre = {x: Math.floor(sumX / tiles.length), y: Math.floor(sumY / tiles.length)};
                }
            }
        }
    }
    return largestCentre;
}

// Generate settlements: 1 city on largest continent, 4 towns, 5 villages
function generateSettlements() {
    console.log('Generating settlements...');
    
    // Find largest continent for city
    const cityLoc = findLargestContinent();
    if (cityLoc) {
        settlements.city = placeSettlement(cityLoc.x, cityLoc.y, 18, TILE_TYPES.CITY_PAVED);
        console.log(`City placed at (${cityLoc.x}, ${cityLoc.y}) with radius 18`);
    }

    // Place 4 towns on random land, avoiding existing settlements
    for (let i = 0; i < 4; i++) {
        const loc = findRandomLandAwayFromSettlements(25);
        if (loc) {
            settlements.towns.push(placeSettlement(loc.x, loc.y, 10, TILE_TYPES.TOWN_ROAD));
            console.log(`Town ${i + 1} placed at (${loc.x}, ${loc.y}) with radius 10`);
        }
    }

    // Place 5 villages on random land, avoiding existing settlements
    for (let i = 0; i < 5; i++) {
        const loc = findRandomLandAwayFromSettlements(15);
        if (loc) {
            settlements.villages.push(placeSettlement(loc.x, loc.y, 5, TILE_TYPES.VILLAGE_MUD));
            console.log(`Village ${i + 1} placed at (${loc.x}, ${loc.y}) with radius 5`);
        }
    }
    
    console.log(`Settlement generation complete: 1 city, ${settlements.towns.length} towns, ${settlements.villages.length} villages`);
}

function findRandomLandAwayFromSettlements(minDistance) {
    for (let attempt = 0; attempt < 200; attempt++) {
        const x = Math.floor(Math.random() * WORLD_WIDTH);
        const y = Math.floor(Math.random() * WORLD_HEIGHT);
        const tType = getTileType(x, y);
        if (tType !== TILE_TYPES.DEEP_WATER && tType !== TILE_TYPES.SHALLOW_WATER && tType !== TILE_TYPES.ROCK) {
            // Check distance from existing settlements
            let tooClose = false;
            if (settlements.city) {
                const d = Math.hypot(x - settlements.city.cx, y - settlements.city.cy);
                if (d < settlements.city.radius + minDistance) tooClose = true;
            }
            for (const town of settlements.towns) {
                const d = Math.hypot(x - town.cx, y - town.cy);
                if (d < town.radius + minDistance) tooClose = true;
            }
            for (const village of settlements.villages) {
                const d = Math.hypot(x - village.cx, y - village.cy);
                if (d < village.radius + minDistance) tooClose = true;
            }
            if (!tooClose) return {x, y};
        }
    }
    return null;
}

function placeSettlement(cx, cy, radius, floorType) {
    const tiles = [];
    for (let dy = -radius; dy <= radius; dy++) {
        for (let dx = -radius; dx <= radius; dx++) {
            if (dx * dx + dy * dy <= radius * radius) {
                const x = cx + dx, y = cy + dy;
                if (x >= 0 && x < WORLD_WIDTH && y >= 0 && y < WORLD_HEIGHT) {
                    const tType = getTileType(x, y);
                    if (tType !== TILE_TYPES.DEEP_WATER && tType !== TILE_TYPES.SHALLOW_WATER) {
                        // Override the chunk tile to settlement floor
                        const chunkX = Math.floor(x / CHUNK_SIZE);
                        const chunkY = Math.floor(y / CHUNK_SIZE);
                        const chunkKey = `${chunkX},${chunkY}`;
                        if (!chunks[chunkKey]) {
                            chunks[chunkKey] = generateChunk(chunkX, chunkY);
                        }
                        const localX = ((x % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
                        const localY = ((y % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
                        chunks[chunkKey][localY][localX] = floorType;
                        tiles.push({x, y});
                    }
                }
            }
        }
    }
    return {cx, cy, radius, tiles};
}

// Spawn NPCs in settlements: more in larger settlements
function spawnNPCsInSettlements() {
    console.log('Spawning NPCs in settlements...');
    
    // City: 30 NPCs with royalty
    if (settlements.city) {
        spawnNPCsInCity(settlements.city.cx, settlements.city.cy, settlements.city.radius, 30);
    }
    
    // Towns: 12 NPCs each (common only)
    for (const town of settlements.towns) {
        spawnNPCsInArea(town.cx, town.cy, town.radius, 12, 'town', NPC_TYPES.common);
    }
    
    // Villages: 5 NPCs each (common only, except one undead village)
    let undeadVillageSpawned = false;
    for (const village of settlements.villages) {
        if (!undeadVillageSpawned && Math.random() < 0.5) {
            // This is the undead village
            spawnNPCsInArea(village.cx, village.cy, village.radius, 5, 'undead village', NPC_TYPES.undead);
            undeadVillageSpawned = true;
        } else {
            spawnNPCsInArea(village.cx, village.cy, village.radius, 5, 'village', NPC_TYPES.common);
        }
    }
    
    // If no undead village was spawned, force the last village to be undead
    if (!undeadVillageSpawned && settlements.villages.length > 0) {
        const lastVillage = settlements.villages[settlements.villages.length - 1];
        spawnNPCsInArea(lastVillage.cx, lastVillage.cy, lastVillage.radius, 5, 'undead village', NPC_TYPES.undead);
    }
    
    console.log(`Total NPCs spawned: ${npcs.length}`);
}

// City spawning: guaranteed royals + even spread of common types
function spawnNPCsInCity(cx, cy, radius, count) {
    const spawnedUnique = new Set();
    
    // Spawn unique royals first (King, Queen - one each max)
    for (const royal of NPC_TYPES.royal.filter(r => r.unique)) {
        if (trySpawnNPC(cx, cy, radius, royal)) {
            spawnedUnique.add(royal.name);
        }
    }
    
    // Spawn at least one of each non-unique royal (Prince, Princess)
    for (const royal of NPC_TYPES.royal.filter(r => !r.unique)) {
        trySpawnNPC(cx, cy, radius, royal);
    }
    
    // Fill remaining slots with even spread of common types
    const remaining = count - npcs.filter(n => 
        n.x >= (cx - radius) * TILE_SIZE && n.x <= (cx + radius) * TILE_SIZE &&
        n.y >= (cy - radius) * TILE_SIZE && n.y <= (cy + radius) * TILE_SIZE
    ).length;
    
    spawnEvenSpread(cx, cy, radius, remaining, NPC_TYPES.common);
    console.log(`Spawned city NPCs at (${cx}, ${cy}) - royals spawned: ${spawnedUnique.size}`);
}

// Town/village spawning: even spread of specified type pool
function spawnNPCsInArea(cx, cy, radius, count, type, typePool) {
    spawnEvenSpread(cx, cy, radius, count, typePool);
    console.log(`Spawned ${count} NPCs at ${type} (${cx}, ${cy})`);
}

// Helper: try to spawn a specific NPC type
function trySpawnNPC(cx, cy, radius, npcType, maxTries = 100) {
    for (let i = 0; i < maxTries; i++) {
        const ang = Math.random() * Math.PI * 2;
        const dist = Math.random() * radius * 0.8;
        const x = (cx + Math.cos(ang) * dist) * TILE_SIZE;
        const y = (cy + Math.sin(ang) * dist) * TILE_SIZE;
        if (isWalkable(x, y, false, false)) {
            npcs.push({
                x, y,
                emoji: npcType.emoji,
                name: npcType.name,
                speech: npcType.speech,
                phase: Math.random() * Math.PI * 2
            });
            return true;
        }
    }
    return false;
}

// Helper: spawn NPCs with even type distribution
function spawnEvenSpread(cx, cy, radius, count, typePool) {
    const typeCounts = new Map();
    typePool.forEach(t => typeCounts.set(t.name, 0));
    
    let spawned = 0, tries = 0;
    while (spawned < count && tries++ < 500) {
        // Pick least-used type for even spread
        let minCount = Infinity;
        let candidates = [];
        for (const [name, cnt] of typeCounts) {
            if (cnt < minCount) {
                minCount = cnt;
                candidates = [name];
            } else if (cnt === minCount) {
                candidates.push(name);
            }
        }
        const chosenName = candidates[Math.floor(Math.random() * candidates.length)];
        const npcType = typePool.find(t => t.name === chosenName);
        
        if (trySpawnNPC(cx, cy, radius, npcType, 20)) {
            typeCounts.set(chosenName, typeCounts.get(chosenName) + 1);
            spawned++;
        }
    }
}

async function initializeGame() {
    
    frameTimeSum = 0;
    frameCount = 0;
    lastFrameTime = performance.now();
    animalPathTimeSum = 0;
    
    loadingIndicator.style.display = 'block';

    // Find a walkable spawn point
    function findWalkableSpawn(centerX, centerY) {
        // Try center first
        if (isWalkable(centerX * TILE_SIZE, centerY * TILE_SIZE, false, false)) {
            return { x: centerX, y: centerY };
        }
        
        // Search in concentric circles
        for (let radius = 1; radius < 50; radius++) {
            for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 8) {
                const testX = Math.floor(centerX + Math.cos(angle) * radius);
                const testY = Math.floor(centerY + Math.sin(angle) * radius);
                
                if (testX >= 0 && testX < WORLD_WIDTH && testY >= 0 && testY < WORLD_HEIGHT) {
                    if (isWalkable(testX * TILE_SIZE, testY * TILE_SIZE, false, false)) {
                        return { x: testX, y: testY };
                    }
                }
            }
        }
        
        // Fallback to original position if nothing found (shouldn't happen)
        return { x: centerX, y: centerY };
    }

    let startX = Math.floor(Math.random() * WORLD_WIDTH);
    let startY = Math.floor(Math.random() * WORLD_HEIGHT);
    const spawn = findWalkableSpawn(startX, startY);
    startX = spawn.x;
    startY = spawn.y;

    player.x = startX * TILE_SIZE + TILE_SIZE / 2;
    player.y = startY * TILE_SIZE + TILE_SIZE / 2;
    camera.x = player.x - canvas.width / 2;
    camera.y = player.y - canvas.height / 2;

    await loadNewArea();

    // Generate settlements after world is loaded
    generateSettlements();

    // Spawn NPCs in settlements instead of near player
    spawnNPCsInSettlements();

    loadingIndicator.style.display = 'none';
    gameLoop();
}


// Debug mode toggle with D key
document.addEventListener('keydown', (event) => {
    if (event.key === 'd' || event.key === 'D') {
        debugMode = !debugMode;
        console.log('Debug mode:', debugMode ? 'ON' : 'OFF');
    }
    if (event.key === 'w' || event.key === 'W') {
        worldMapVisible = !worldMapVisible;
        gamePaused = worldMapVisible;
        worldMapCanvas.style.display = worldMapVisible ? 'block' : 'none';
        minimapCanvas.style.display = worldMapVisible ? 'none' : 'block';
        if (worldMapVisible) {
            drawWorldMap();
        }
        console.log('World map:', worldMapVisible ? 'ON' : 'OFF');
    }
});

canvas.addEventListener('click', async (event) => {
    const clickX = event.clientX + camera.x;
    const clickY = event.clientY + camera.y;
    
    // Snap click to tile center
    const tileX = Math.floor(clickX / TILE_SIZE);
    const tileY = Math.floor(clickY / TILE_SIZE);
    const centeredX = tileX * TILE_SIZE + TILE_SIZE / 2;
    const centeredY = tileY * TILE_SIZE + TILE_SIZE / 2;

    if (centeredX > player.x) {
        player.direction = 'right';
    } else {
        player.direction = 'left';
    }

    // Check if the clicked destination is valid (walkable on foot or in boat)
    const targetTileType = getTileType(tileX, tileY);
    const isWaterTile = targetTileType === TILE_TYPES.DEEP_WATER || targetTileType === TILE_TYPES.SHALLOW_WATER;
    const isRockTile = targetTileType === TILE_TYPES.ROCK;
    const isSnowTile = targetTileType === TILE_TYPES.SNOW;
    const isMountainRock = targetTileType === TILE_TYPES.MOUNTAIN_ROCK;
    
    // If clicked on unclimbable rock, find nearest adjacent walkable tile
    if (isRockTile) {
        // Find direction from player to click
        const dx = centeredX - player.x;
        const dy = centeredY - player.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance > 0) {
            // Normalize direction and step back one tile
            const dirX = dx / distance;
            const dirY = dy / distance;
            
            // Try to find a walkable tile adjacent to the rock
            for (let offset = TILE_SIZE; offset <= TILE_SIZE * 3; offset += TILE_SIZE) {
                const newX = centeredX - dirX * offset;
                const newY = centeredY - dirY * offset;
                const newTileX = Math.floor(newX / TILE_SIZE);
                const newTileY = Math.floor(newY / TILE_SIZE);
                const newTileType = getTileType(newTileX, newTileY);
                
                if (newTileType !== TILE_TYPES.ROCK && newTileType !== TILE_TYPES.MOUNTAIN_ROCK && 
                    newTileType !== TILE_TYPES.SNOW && newTileType !== TILE_TYPES.DEEP_WATER) {
                    target = {x: newTileX * TILE_SIZE + TILE_SIZE / 2, y: newTileY * TILE_SIZE + TILE_SIZE / 2};
                    path = findPath(player.x, player.y, target.x, target.y, undefined, MAX_SEARCH_DISTANCE);
                    
                    if (path) {
                        console.log('Navigating to tile adjacent to rock');
                        statusElement.textContent = 'Moving near rock';
                        return;
                    }
                    break;
                }
            }
        }
        
        console.log('Cannot walk on rocks');
        statusElement.textContent = 'Cannot walk on that terrain';
        return;
    }
    
    // If not in boat and clicking water, or in boat and clicking land - let pathfinding handle the transition
    // Player can swim if needed, so don't block water clicks

    target = {x: centeredX, y: centeredY};
    path = findPath(player.x, player.y, centeredX, centeredY, undefined, MAX_SEARCH_DISTANCE);

    if (!path) {
        console.log('No path found or destination too far');
        target = null;
        statusElement.textContent = 'Destination unreachable or too far';
    } else {
        lastPathCompletionTime = Date.now(); // Reset the timer when the user clicks
    }
});

// Modify the pathfinding form submission handler to reset the timer
pathfindingForm.addEventListener('submit', async (event) => {
    event.preventDefault();
    const targetX = parseInt(targetXInput.value) * TILE_SIZE + TILE_SIZE / 2;
    const targetY = parseInt(targetYInput.value) * TILE_SIZE + TILE_SIZE / 2;

    target = {x: targetX, y: targetY};
    path = findPath(player.x, player.y, targetX, targetY, undefined, MAX_SEARCH_DISTANCE);

    if (!path) {
        console.log('No path found or destination too far');
        target = null;
        statusElement.textContent = 'Destination unreachable or too far';
    } else {
        lastPathCompletionTime = Date.now(); // Reset the timer when a new path is set
    }

    pathfindingDialog.style.display = 'none';
});

window.addEventListener('resize', () => {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
});

initializeGame();
</script>
</body>
</html>